# Документ требований: Конструктор форм для Umbraco CMS

## Введение

Конструктор форм - это модуль для Umbraco CMS, который позволяет редакторам контента создавать и управлять формами обратной связи через бэкофис без необходимости программирования. Система интегрируется с существующей инфраструктурой отправки email (MailKit), использует reCAPTCHA для защиты от спама и сохраняет все отправки в базу данных для последующего анализа.

## Глоссарий

- **Система** - Конструктор форм Umbraco CMS
- **Редактор** - Пользователь бэкофиса Umbraco, создающий и настраивающий формы
- **Посетитель** - Пользователь фронтенда, заполняющий и отправляющий форму
- **FormField** - Document Type для определения одного поля формы
- **FormBuilderBlock** - Document Type для настройки всей формы
- **FormSubmission** - Отправка формы посетителем
- **IEmailService** - Существующий сервис для отправки email через MailKit
- **FormBuilderController** - SurfaceController для обработки отправки форм
- **FormSubmissionDto** - DTO для передачи данных отправки формы
- **Repository** - Паттерн для сохранения данных в БД
- **Toast_Notification** - Всплывающее уведомление для пользователя
- **reCAPTCHA** - Сервис Google для защиты от ботов

## Требования

### Требование 1: Создание структуры полей формы

**Пользовательская история:** Как редактор, я хочу определять отдельные поля формы с различными типами и настройками валидации, чтобы собирать нужную информацию от посетителей.

#### Критерии приемки

1. КОГДА редактор создает Document Type formField, ТО Система ДОЛЖНА предоставить следующие свойства:
   - fieldLabel (Textstring) - надпись над полем
   - fieldType (Dropdown) - тип поля с опциями: text, email, phone, textarea, checkbox, radio, select
   - fieldPlaceholder (Textstring) - текст подсказки внутри поля
   - isRequired (Checkbox) - флаг обязательности поля
   - validationPattern (Textstring) - регулярное выражение для валидации
   - errorMessage (Textstring) - сообщение об ошибке валидации

2. КОГДА редактор заполняет свойство fieldLabel, ТО Система ДОЛЖНА сохранить текст для отображения над полем формы

3. КОГДА редактор выбирает fieldType, ТО Система ДОЛЖНА ограничить выбор следующими типами: text, email, phone, textarea, checkbox, radio, select

4. КОГДА редактор устанавливает isRequired в true, ТО Система ДОЛЖНА пометить поле как обязательное для заполнения

5. КОГДА редактор указывает validationPattern, ТО Система ДОЛЖНА использовать это регулярное выражение для валидации введенных данных

### Требование 2: Создание блока формы

**Пользовательская история:** Как редактор, я хочу создавать полноценные формы с настройками отображения и отправки email, чтобы собирать обратную связь от посетителей.

#### Критерии приемки

1. КОГДА редактор создает Document Type formBuilderBlock, ТО Система ДОЛЖНА предоставить вкладку "Form Settings" со следующими свойствами:
   - formTitle (Textstring) - заголовок формы
   - formDescription (Textarea) - описание под заголовком
   - formFields (Block List) - список полей формы типа formField
   - submitButtonText (Textstring) - текст кнопки отправки

2. КОГДА редактор создает Document Type formBuilderBlock, ТО Система ДОЛЖНА предоставить вкладку "Email Settings" со следующими свойствами:
   - emailRecipient (Textstring) - email адрес получателя
   - emailSubject (Textstring) - тема письма
   - successMessage (Textarea) - сообщение после успешной отправки
   - redirectPage (Content Picker) - опциональная страница для редиректа

3. КОГДА редактор добавляет поля в formFields через Block List, ТО Система ДОЛЖНА позволить добавлять неограниченное количество элементов formField

4. КОГДА редактор не указывает submitButtonText, ТО Система ДОЛЖНА использовать значение по умолчанию "Отправить"

5. КОГДА редактор указывает redirectPage, ТО Система ДОЛЖНА сохранить ссылку на страницу для редиректа после отправки

### Требование 3: Динамическое построение формы

**Пользовательская история:** Как посетитель, я хочу видеть форму с полями, настроенными редактором, чтобы заполнить и отправить свои данные.

#### Критерии приемки

1. КОГДА представление FormBuilderBlock.cshtml рендерится, ТО Система ДОЛЖНА отобразить formTitle как заголовок формы

2. КОГДА представление FormBuilderBlock.cshtml рендерится, ТО Система ДОЛЖНА отобразить formDescription под заголовком, если оно заполнено

3. КОГДА представление обрабатывает formFields, ТО Система ДОЛЖНА создать HTML элемент для каждого поля согласно его fieldType

4. КОГДА поле имеет fieldType "text", ТО Система ДОЛЖНА создать элемент input type="text"

5. КОГДА поле имеет fieldType "email", ТО Система ДОЛЖНА создать элемент input type="email"

6. КОГДА поле имеет fieldType "phone", ТО Система ДОЛЖНА создать элемент input type="tel"

7. КОГДА поле имеет fieldType "textarea", ТО Система ДОЛЖНА создать элемент textarea

8. КОГДА поле имеет fieldType "checkbox", ТО Система ДОЛЖНА создать элемент input type="checkbox"

9. КОГДА поле имеет fieldType "radio", ТО Система ДОЛЖНА создать элемент input type="radio"

10. КОГДА поле имеет fieldType "select", ТО Система ДОЛЖНА создать элемент select с опциями

11. КОГДА поле имеет fieldLabel, ТО Система ДОЛЖНА отобразить label элемент с этим текстом

12. КОГДА поле имеет fieldPlaceholder, ТО Система ДОЛЖНА установить атрибут placeholder для input элемента

13. КОГДА поле имеет isRequired установленным в true, ТО Система ДОЛЖНА добавить атрибут required к элементу формы

14. КОГДА представление рендерит кнопку отправки, ТО Система ДОЛЖНА использовать текст из submitButtonText

### Требование 4: Client-side валидация

**Пользовательская история:** Как посетитель, я хочу получать мгновенную обратную связь о корректности заполнения полей, чтобы исправить ошибки до отправки формы.

#### Критерии приемки

1. КОГДА поле имеет isRequired установленным в true И посетитель пытается отправить форму с пустым полем, ТО Система ДОЛЖНА предотвратить отправку и показать сообщение об ошибке

2. КОГДА поле имеет validationPattern И посетитель вводит данные не соответствующие паттерну, ТО Система ДОЛЖНА показать errorMessage для этого поля

3. КОГДА поле имеет fieldType "email" И посетитель вводит некорректный email адрес, ТО Система ДОЛЖНА показать сообщение об ошибке валидации email

4. КОГДА поле имеет fieldType "phone" И посетитель вводит некорректный номер телефона, ТО Система ДОЛЖНА показать сообщение об ошибке валидации телефона

5. КОГДА все обязательные поля заполнены корректно, ТО Система ДОЛЖНА разрешить отправку формы

### Требование 5: Server-side валидация

**Пользовательская история:** Как администратор системы, я хочу иметь серверную валидацию данных формы, чтобы защититься от обхода client-side валидации.

#### Критерии приемки

1. КОГДА FormBuilderController получает POST запрос, ТО Система ДОЛЖНА проверить все поля с isRequired на наличие значений

2. КОГДА поле имеет validationPattern, ТО Система ДОЛЖНА проверить соответствие значения регулярному выражению на сервере

3. ЕСЛИ серверная валидация не пройдена, ТО Система ДОЛЖНА вернуть форму с сообщениями об ошибках

4. КОГДА поле имеет fieldType "email", ТО Система ДОЛЖНА проверить корректность email адреса на сервере

5. ЕСЛИ все проверки пройдены успешно, ТО Система ДОЛЖНА продолжить обработку отправки формы

### Требование 6: Защита от спама через reCAPTCHA

**Пользовательская история:** Как администратор системы, я хочу защитить формы от автоматических отправок ботами, чтобы получать только легитимные обращения.

#### Критерии приемки

1. КОГДА форма рендерится, ТО Система ДОЛЖНА включить виджет reCAPTCHA

2. КОГДА посетитель отправляет форму, ТО Система ДОЛЖНА отправить reCAPTCHA токен на сервер

3. КОГДА FormBuilderController получает POST запрос, ТО Система ДОЛЖНА проверить reCAPTCHA токен через API Google

4. ЕСЛИ проверка reCAPTCHA не пройдена, ТО Система ДОЛЖНА отклонить отправку и показать сообщение об ошибке

5. ЕСЛИ проверка reCAPTCHA пройдена успешно, ТО Система ДОЛЖНА продолжить обработку отправки формы

### Требование 7: Отправка email уведомлений

**Пользовательская история:** Как получатель формы, я хочу получать email уведомления о новых отправках, чтобы своевременно реагировать на обращения посетителей.

#### Критерии приемки

1. КОГДА FormBuilderController обрабатывает валидную отправку формы, ТО Система ДОЛЖНА создать FormSubmissionDto с данными всех полей

2. КОГДА FormSubmissionDto создан, ТО Система ДОЛЖНА вызвать метод SendFormSubmissionAsync интерфейса IEmailService

3. КОГДА IEmailService.SendFormSubmissionAsync вызывается, ТО Система ДОЛЖНА отправить email на адрес из emailRecipient

4. КОГДА email формируется, ТО Система ДОЛЖНА использовать emailSubject как тему письма

5. КОГДА email формируется, ТО Система ДОЛЖНА включить в тело письма все заполненные поля формы с их значениями

6. КОГДА email формируется, ТО Система ДОЛЖНА включить дату и время отправки формы

7. КОГДА отправка email завершена успешно, ТО Система ДОЛЖНА продолжить обработку отправки формы

### Требование 8: Сохранение отправок в базу данных

**Пользовательская история:** Как администратор системы, я хочу сохранять все отправки форм в базу данных, чтобы иметь историю обращений и возможность анализа.

#### Критерии приемки

1. КОГДА FormBuilderController обрабатывает валидную отправку формы, ТО Система ДОЛЖНА создать сущность FormSubmission

2. КОГДА сущность FormSubmission создается, ТО Система ДОЛЖНА сохранить следующие данные:
   - ID формы (formBuilderBlock)
   - Дата и время отправки
   - IP адрес отправителя
   - Данные всех полей в структурированном формате (JSON)

3. КОГДА сущность FormSubmission заполнена, ТО Система ДОЛЖНА использовать Repository pattern для сохранения в БД

4. КОГДА сохранение в БД завершено успешно, ТО Система ДОЛЖНА продолжить обработку отправки формы

5. ЕСЛИ сохранение в БД не удалось, ТО Система ДОЛЖНА залогировать ошибку, но продолжить обработку (не блокировать отправку email)

### Требование 9: Уведомления пользователя о результате отправки

**Пользовательская история:** Как посетитель, я хочу получать четкую обратную связь о результате отправки формы, чтобы понимать, была ли моя форма обработана успешно.

#### Критерии приемки

1. КОГДА отправка формы обработана успешно И redirectPage не указана, ТО Система ДОЛЖНА показать Toast_Notification с текстом из successMessage

2. КОГДА отправка формы обработана успешно И redirectPage указана, ТО Система ДОЛЖНА выполнить редирект на указанную страницу

3. КОГДА происходит ошибка валидации, ТО Система ДОЛЖНА показать Toast_Notification с описанием ошибок валидации

4. КОГДА происходит ошибка reCAPTCHA, ТО Система ДОЛЖНА показать Toast_Notification с сообщением "Проверка reCAPTCHA не пройдена. Попробуйте еще раз."

5. КОГДА происходит ошибка отправки email, ТО Система ДОЛЖНА показать Toast_Notification с сообщением "Произошла ошибка при отправке формы. Попробуйте позже."

6. КОГДА происходит любая системная ошибка, ТО Система ДОЛЖНА показать Toast_Notification с общим сообщением об ошибке

### Требование 10: Расширение IEmailService

**Пользовательская история:** Как разработчик, я хочу расширить существующий IEmailService для поддержки отправки форм, чтобы использовать единую инфраструктуру email.

#### Критерии приемки

1. КОГДА интерфейс IEmailService расширяется, ТО Система ДОЛЖНА добавить метод SendFormSubmissionAsync с параметрами:
   - FormSubmissionDto (данные формы)
   - string recipientEmail (получатель)
   - string subject (тема письма)

2. КОГДА класс EmailService реализует SendFormSubmissionAsync, ТО Система ДОЛЖНА использовать существующую конфигурацию MailKit

3. КОГДА SendFormSubmissionAsync вызывается, ТО Система ДОЛЖНА форматировать данные FormSubmissionDto в читаемый HTML формат

4. КОГДА SendFormSubmissionAsync формирует HTML, ТО Система ДОЛЖНА включить все поля формы с их labels и значениями

5. КОГДА SendFormSubmissionAsync отправляет email, ТО Система ДОЛЖНА использовать существующую логику обработки ошибок MailKit

### Требование 11: Создание FormSubmissionDto

**Пользовательская история:** Как разработчик, я хочу иметь типизированный DTO для передачи данных формы между слоями, чтобы обеспечить безопасность типов и удобство работы.

#### Критерии приемки

1. КОГДА создается класс FormSubmissionDto, ТО Система ДОЛЖНА включить следующие свойства:
   - int FormId (ID формы)
   - string FormTitle (название формы)
   - DateTime SubmittedAt (дата и время отправки)
   - string IpAddress (IP адрес отправителя)
   - Dictionary<string, string> FieldValues (пары "название поля - значение")

2. КОГДА FormBuilderController создает FormSubmissionDto, ТО Система ДОЛЖНА заполнить все свойства корректными значениями из запроса

3. КОГДА FieldValues заполняется, ТО Система ДОЛЖНА использовать fieldLabel как ключ и введенное значение как значение

4. КОГДА FormSubmissionDto передается между слоями, ТО Система ДОЛЖНА сохранять все данные без потерь

### Требование 12: Создание FormBuilderController

**Пользовательская история:** Как разработчик, я хочу иметь специализированный контроллер для обработки отправки форм, чтобы инкапсулировать всю логику обработки в одном месте.

#### Критерии приемки

1. КОГДА создается FormBuilderController, ТО Система ДОЛЖНА наследовать его от SurfaceController

2. КОГДА FormBuilderController создается, ТО Система ДОЛЖНА внедрить зависимости:
   - IEmailService (для отправки email)
   - IFormSubmissionRepository (для сохранения в БД)
   - IReCaptchaService (для проверки reCAPTCHA)

3. КОГДА FormBuilderController получает POST запрос, ТО Система ДОЛЖНА выполнить следующие шаги в указанном порядке:
   - Проверка reCAPTCHA
   - Server-side валидация полей
   - Создание FormSubmissionDto
   - Сохранение в БД через Repository
   - Отправка email через IEmailService
   - Возврат результата (редирект или JSON для Toast_Notification)

4. КОГДА любой шаг обработки завершается ошибкой, ТО Система ДОЛЖНА залогировать ошибку и вернуть соответствующее сообщение пользователю

5. КОГДА все шаги выполнены успешно, ТО Система ДОЛЖНА вернуть успешный результат

### Требование 13: Поддержка различных типов полей

**Пользовательская история:** Как редактор, я хочу использовать различные типы полей в формах, чтобы собирать разнообразную информацию в удобном формате.

#### Критерии приемки

1. КОГДА поле имеет тип "text", ТО Система ДОЛЖНА отображать однострочное текстовое поле

2. КОГДА поле имеет тип "email", ТО Система ДОЛЖНА отображать поле с валидацией email адреса

3. КОГДА поле имеет тип "phone", ТО Система ДОЛЖНА отображать поле с валидацией номера телефона

4. КОГДА поле имеет тип "textarea", ТО Система ДОЛЖНА отображать многострочное текстовое поле

5. КОГДА поле имеет тип "checkbox", ТО Система ДОЛЖНА отображать чекбокс с возможностью выбора

6. КОГДА поле имеет тип "radio", ТО Система ДОЛЖНА отображать радио-кнопку для выбора одного варианта

7. КОГДА поле имеет тип "select", ТО Система ДОЛЖНА отображать выпадающий список с опциями

8. ДЛЯ ВСЕХ типов полей, Система ДОЛЖНА корректно обрабатывать и сохранять введенные значения

### Требование 14: Кастомная валидация через регулярные выражения

**Пользовательская история:** Как редактор, я хочу задавать собственные правила валидации через регулярные выражения, чтобы контролировать формат вводимых данных.

#### Критерии приемки

1. КОГДА редактор указывает validationPattern для поля, ТО Система ДОЛЖНА применить это регулярное выражение для валидации на клиенте

2. КОГДА редактор указывает validationPattern для поля, ТО Система ДОЛЖНА применить это регулярное выражение для валидации на сервере

3. КОГДА validationPattern не соответствует введенным данным, ТО Система ДОЛЖНА показать errorMessage указанное редактором

4. КОГДА validationPattern не указан, ТО Система ДОЛЖНА использовать только стандартную валидацию для типа поля

5. КОГДА validationPattern указан некорректно (невалидное регулярное выражение), ТО Система ДОЛЖНА залогировать ошибку и пропустить кастомную валидацию

### Требование 15: Интеграция с существующей архитектурой

**Пользовательская история:** Как разработчик, я хочу чтобы конструктор форм следовал существующим архитектурным паттернам проекта, чтобы обеспечить консистентность кодовой базы.

#### Критерии приемки

1. КОГДА создается слой Application, ТО Система ДОЛЖНА использовать существующий паттерн с интерфейсами и реализациями

2. КОГДА создается Repository, ТО Система ДОЛЖНА следовать существующему Repository pattern проекта

3. КОГДА создаются DTO, ТО Система ДОЛЖНА размещать их в соответствующем слое согласно архитектуре проекта

4. КОГДА создается контроллер, ТО Система ДОЛЖНА использовать dependency injection для всех зависимостей

5. КОГДА происходит обработка ошибок, ТО Система ДОЛЖНА использовать существующую систему логирования проекта

6. КОГДА отправляются уведомления пользователю, ТО Система ДОЛЖНА использовать существующую систему Toast_Notification

7. КОГДА интегрируется reCAPTCHA, ТО Система ДОЛЖНА использовать существующую конфигурацию и сервисы проекта
