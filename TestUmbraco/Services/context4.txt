
Структура папки: 
================= 
    BackgroundClassesService.cs
    BackgroundInfo.cs
    BackgroundResult.cs
    ILoggingService.cs
    IMediaCacheService.cs
    IStaticCssGeneratorService.cs
    IUmbracoBackgroundService.cs
    LoggingService.cs
    MediaCacheService.cs
    StaticCssGeneratorService.cs
    temp_full.txt
    UmbracoBackgroundService.cs
    
Подпапки отсутствуют 

 
================= 
 
/BackgroundClassesService.cs: 
using System;
using System.Threading.Tasks;
using Umbraco.Cms.Core.Models.PublishedContent;
using TestUmbraco.Services;

namespace TestUmbraco.Services
{
    public class BackgroundClassesService
    {
        private readonly IUmbracoBackgroundService _backgroundService;

        public BackgroundClassesService(IUmbracoBackgroundService backgroundService)
        {
            _backgroundService = backgroundService;
        }

        public async Task<string> GetBackgroundClasses(
            IPublishedElement settings,
            Guid componentId,
            string prefix = "bg")
        {
            var result = await _backgroundService.ProcessBackground(settings, componentId, prefix);
            return result?.CssClass ?? "";
        }

        public async Task<BackgroundResult> GetBackgroundData(
            IPublishedElement settings,
            Guid componentId,
            string prefix = "bg")
        {
            return await _backgroundService.ProcessBackground(settings, componentId, prefix);
        }
    }
} 
 
/BackgroundInfo.cs: 
using System.Collections.Generic;

namespace TestUmbraco.Services
{
    public class BackgroundInfo
    {
        public string ComponentClass { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
        public string ComponentId { get; set; } = string.Empty;
        public string Url { get; set; } = string.Empty;
        public string Size { get; set; } = "cover";
        public string Position { get; set; } = "center";
        public string VideoId { get; set; } = string.Empty;
        public bool UsePlaceholder { get; set; }
        public string PlaceholderUrl { get; set; } = string.Empty;
        public bool HasOverlay { get; set; }
        public string OverlayClass { get; set; } = string.Empty;
    }
} 
 
/BackgroundResult.cs: 
namespace TestUmbraco.Services
{
    public class BackgroundResult
    {
        public BackgroundType Type { get; set; } = BackgroundType.None;
        public string CssClass { get; set; } = string.Empty;
        public bool HasBackground { get; set; }
        public bool HasOverlay { get; set; }
        public bool IsLazyLoaded { get; set; }
        public bool IsMobileOptimized { get; set; }
        public string OverlayClass { get; set; } = string.Empty;
        public string VideoId { get; set; } = string.Empty;
        public string VideoPlaceholder { get; set; } = string.Empty;
        public bool UseVideoPlaceholder { get; set; }
    }

    public enum BackgroundType
    {
        None,
        Image,
        Color,
        Gradient,
        Video
    }
} 
 
/ILoggingService.cs: 
using Microsoft.Extensions.Configuration;

namespace TestUmbraco.Services
{
    public interface ILoggingService
    {
        bool IsEnabled { get; }
        void LogInformation(string message);
        void LogInformation<T>(string message);
        void LogError(string message);
        void LogError<T>(string message);
        void LogError(string message, Exception exception);
        void LogError<T>(string message, Exception exception);
        void LogWarning(string message);
        void LogWarning<T>(string message);
    }
} 
 
/IMediaCacheService.cs: 
using Microsoft.AspNetCore.Html;
using Umbraco.Cms.Core.Models;
using Umbraco.Cms.Core.Models.PublishedContent;

namespace TestUmbraco.Services
{
    public interface IMediaCacheService
    {
        // Основные методы получения URL
        Task<string?> GetCachedMediaUrlAsync(Guid mediaKey, string? cropAlias = null, int? width = null, int? height = null);
        Task<string?> GetCachedMediaUrlAsync(IPublishedContent? media, string? cropAlias = null, int? width = null, int? height = null);
        
        // Методы для HTML генерации
        Task<IHtmlContent> GetCachedImageHtmlAsync(Guid mediaKey, string? cropAlias = null, Dictionary<string, string>? attributes = null);
        Task<IHtmlContent> GetCachedImageHtmlAsync(IPublishedContent? media, string? cropAlias = null, Dictionary<string, string>? attributes = null);
        
        // Фоновые изображения
        Task<string> GetCachedBackgroundCssAsync(string backgrounds);
        Task<string> GenerateBackgroundCssAsync(Guid mediaGuid, string className, int minHeight = 400, string size = "cover", string position = "center");
        
        // Управление кешем
        void ClearCacheForMedia(Guid mediaKey);
        void ClearAllCache();
        
        // Оптимизация изображений
        string GeneratePictureElement(string? url, string? altText = "", string? title = "", int? width = null, int? height = null, bool lazyLoad = true);
        string ConvertToWebP(string? url);
        string GenerateSrcSet(string? url, string? cropAlias, int baseWidth);
    }
} 
 
/IStaticCssGeneratorService.cs: 
namespace TestUmbraco.Services
{
    public interface IStaticCssGeneratorService
    {
        Task<string> GenerateBackgroundCssFileAsync();
        Task UpdateCssForMediaAsync(Guid mediaKey);
        Task RemoveCssForMediaAsync(Guid mediaKey);
        Task RegenerateAllCssAsync();
        Task<string> AddInlineStyleAsync(string css, string styleType = "custom");
        Task<string> GetOrAddMediaClassAsync(Guid mediaKey, string className, int minHeight = 400, string size = "cover", string position = "center");
        Task<string> GetOrAddColorClassAsync(string colorValue, int minHeight = 400);
        Task<string> GetOrAddGradientClassAsync(string colorStart, string colorEnd, string direction = "to bottom", int minHeight = 400);
        Task<string> AddOverlayStyleAsync(string overlayClass, string css);
    }
} 
 
/IUmbracoBackgroundService.cs: 
using Umbraco.Cms.Core.Models.PublishedContent;

namespace TestUmbraco.Services
{
    public interface IUmbracoBackgroundService
    {
        Task<BackgroundResult> ProcessBackground(IPublishedElement? settings, Guid componentId, string prefix = "bg");
    }
} 
 
/LoggingService.cs: 
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System;

namespace TestUmbraco.Services
{
    public class LoggingService : ILoggingService
    {
        private readonly ILogger<LoggingService> _logger;
        private readonly IConfiguration _configuration;
        
        public bool IsEnabled => _configuration.GetValue<bool>("Logging:Enabled", true);

        public LoggingService(
            IConfiguration configuration,
            ILogger<LoggingService> logger)
        {
            _configuration = configuration;
            _logger = logger;
        }

        public void LogInformation(string message)
        {
            if (!IsEnabled) return;
            _logger.LogInformation(message);
            WriteColored(message, ConsoleColor.Green);
        }

        public void LogInformation<T>(string message)
        {
            if (!IsEnabled) return;
            var fullMessage = $"[{typeof(T).Name}] {message}";
            _logger.LogInformation(fullMessage);
            WriteColored(fullMessage, ConsoleColor.Green);
        }

        public void LogError(string message)
        {
            if (!IsEnabled) return;
            _logger.LogError(message);
            WriteColored(message, ConsoleColor.Red);
        }

        public void LogError<T>(string message)
        {
            if (!IsEnabled) return;
            var fullMessage = $"[{typeof(T).Name}] {message}";
            _logger.LogError(fullMessage);
            WriteColored(fullMessage, ConsoleColor.Red);
        }

        public void LogError(string message, Exception exception)
        {
            if (!IsEnabled) return;
            _logger.LogError(exception, message);
            WriteColored($"{message}: {exception.Message}", ConsoleColor.DarkRed);
        }

        public void LogError<T>(string message, Exception exception)
        {
            if (!IsEnabled) return;
            var fullMessage = $"[{typeof(T).Name}] {message}";
            _logger.LogError(exception, fullMessage);
            WriteColored($"{fullMessage}: {exception.Message}", ConsoleColor.DarkRed);
        }

        public void LogWarning(string message)
        {
            if (!IsEnabled) return;
            _logger.LogWarning(message);
            WriteColored(message, ConsoleColor.Yellow);
        }

        public void LogWarning<T>(string message)
        {
            if (!IsEnabled) return;
            var fullMessage = $"[{typeof(T).Name}] {message}";
            _logger.LogWarning(fullMessage);
            WriteColored(fullMessage, ConsoleColor.Yellow);
        }

        private void WriteColored(string message, ConsoleColor color)
        {
            try
            {
                var originalColor = Console.ForegroundColor;
                Console.ForegroundColor = color;
                Console.WriteLine($"{DateTime.Now:HH:mm:ss} {message}");
                Console.ForegroundColor = originalColor;
            }
            catch
            {
                // Игнорируем ошибки консоли
            }
        }
    }
} 
 
/MediaCacheService.cs: 
using Microsoft.AspNetCore.Html;
using Umbraco.Cms.Core.Cache;
using Umbraco.Cms.Core.Models;
using Umbraco.Cms.Core.Models.PublishedContent;
using Umbraco.Cms.Core.Services;
using Umbraco.Cms.Core.Web;
using Microsoft.AspNetCore.Hosting;
using System.Text;

namespace TestUmbraco.Services
{
    public class MediaCacheService : IMediaCacheService
    {
        private readonly IAppPolicyCache _runtimeCache;
        private readonly IMediaService _mediaService;
        private readonly IUmbracoContextAccessor _umbracoContextAccessor;

        public MediaCacheService(
            AppCaches appCaches,
            IMediaService mediaService,
            IUmbracoContextAccessor umbracoContextAccessor)
        {
            _runtimeCache = appCaches.RuntimeCache;
            _mediaService = mediaService;
            _umbracoContextAccessor = umbracoContextAccessor;
        }

        public async Task<string?> GetCachedMediaUrlAsync(Guid mediaKey, string? cropAlias = null, int? width = null, int? height = null)
        {
            var cacheKey = $"media_url_{mediaKey}_{cropAlias}_{width}_{height}";
            
            // Используем GetCacheItem с синхронным делегатом
            return await _runtimeCache.GetCacheItemAsync(cacheKey, async () =>
            {
                try
                {
                    var media = _mediaService.GetById(mediaKey);
                    
                    if (media == null)
                    {
                        return null; // Явно возвращаем null
                    }

                    string? url = null;
                    
                    if (_umbracoContextAccessor.TryGetUmbracoContext(out var umbracoContext))
                    {
                        var publishedMedia = umbracoContext.Media?.GetById(mediaKey);
                        url = publishedMedia?.Url();
                    }
                    else
                    {
                        url = media.GetValue<string>("umbracoFile");
                    }

                    if (string.IsNullOrEmpty(url))
                    {
                        return null; // Явно возвращаем null
                    }

                    var parameters = new List<string>();
                    
                    if (!string.IsNullOrEmpty(cropAlias))
                    {
                        parameters.Add($"crop={cropAlias}");
                    }
                    
                    if (width.HasValue)
                    {
                        parameters.Add($"width={width}");
                    }
                    
                    if (height.HasValue)
                    {
                        parameters.Add($"height={height}");
                    }
                    
                    var version = media.UpdateDate != default ? media.UpdateDate.Ticks.ToString() : DateTime.UtcNow.Ticks.ToString();
                    
                    string finalUrl;
                    if (parameters.Any())
                    {
                        finalUrl = $"{url}?{string.Join("&", parameters)}&v={version}";
                    }
                    else if (!url.Contains("?"))
                    {
                        finalUrl = $"{url}?v={version}";
                    }
                    else
                    {
                        finalUrl = $"{url}&v={version}";
                    }

                    return finalUrl;
                }
                catch (Exception)
                {
                    return null; // Явно возвращаем null
                }
            }, TimeSpan.FromHours(1));
        }

        public async Task<string?> GetCachedMediaUrlAsync(IPublishedContent? media, string? cropAlias = null, int? width = null, int? height = null)
        {
            if (media == null)
            {
                return null; // Явно возвращаем null
            }
            
            return await GetCachedMediaUrlAsync(media.Key, cropAlias, width, height);
        }

        public async Task<IHtmlContent> GetCachedImageHtmlAsync(Guid mediaKey, string? cropAlias = null, Dictionary<string, string>? attributes = null)
        {
            var cacheKey = $"media_html_{mediaKey}_{cropAlias}_{(attributes != null ? string.Join("_", attributes) : "")}";
            
            return await _runtimeCache.GetCacheItemAsync(cacheKey, async () =>
            {
                try
                {
                    var media = _mediaService.GetById(mediaKey);
                    if (media == null)
                    {
                        return new HtmlString(string.Empty);
                    }
                    
                    var url = await GetCachedMediaUrlAsync(mediaKey, cropAlias);
                    if (string.IsNullOrEmpty(url))
                    {
                        return new HtmlString(string.Empty);
                    }

                    string? altText = media.GetValue<string>("altText") ?? media.Name;
                    string? title = media.GetValue<string>("title") ?? string.Empty;
                    
                    var html = GeneratePictureElement(url, altText, title, 
                        media.GetValue<int?>("width"), 
                        media.GetValue<int?>("height"), 
                        true);

                    return new HtmlString(html);
                }
                catch (Exception)
                {
                    return new HtmlString(string.Empty);
                }
            }, TimeSpan.FromMinutes(30));
        }

        public async Task<IHtmlContent> GetCachedImageHtmlAsync(IPublishedContent? media, string? cropAlias = null, Dictionary<string, string>? attributes = null)
        {
            if (media == null)
            {
                return new HtmlString(string.Empty);
            }
            
            return await GetCachedImageHtmlAsync(media.Key, cropAlias, attributes);
        }

        public async Task<string> GetCachedBackgroundCssAsync(string backgrounds)
        {
            var cacheKey = $"bg_css_{backgrounds.GetHashCode()}";
            
            var cachedValue = await _runtimeCache.GetCacheItemAsync(cacheKey, async () =>
            {
                var cssBuilder = new StringBuilder();
                var backgroundItems = backgrounds.Split('|', StringSplitOptions.RemoveEmptyEntries);
                
                foreach (var item in backgroundItems)
                {
                    var parts = item.Split(':');
                    if (parts.Length >= 2)
                    {
                        if (Guid.TryParse(parts[0], out Guid mediaGuid))
                        {
                            var className = parts[1];
                            var minHeight = parts.Length > 2 && int.TryParse(parts[2], out var mh) ? mh : 400;
                            var size = parts.Length > 3 ? parts[3] : "cover";
                            var position = parts.Length > 4 ? parts[4] : "center";
                            
                            var css = await GenerateBackgroundCssAsync(mediaGuid, className, minHeight, size, position);
                            if (!string.IsNullOrEmpty(css))
                                cssBuilder.AppendLine(css);
                        }
                    }
                }
                
                return cssBuilder.ToString();
            }, TimeSpan.FromHours(1));

            return cachedValue ?? string.Empty;
        }

        public async Task<string> GenerateBackgroundCssAsync(Guid mediaGuid, string className, int minHeight = 400, string size = "cover", string position = "center")
        {
            var url = await GetCachedMediaUrlAsync(mediaGuid);
            if (string.IsNullOrEmpty(url))
                return string.Empty;
            
            return $@".{className} {{
    background-image: url('{url}');
    background-size: {size};
    background-position: {position};
    background-repeat: no-repeat;
    min-height: {minHeight}px;
}}";
        }

        public void ClearCacheForMedia(Guid mediaKey)
        {
            _runtimeCache.ClearByKey($"media_url_{mediaKey}");
            _runtimeCache.ClearByKey($"media_html_{mediaKey}");
        }

        public void ClearAllCache()
        {
            _runtimeCache.Clear();
        }

        public string GeneratePictureElement(string? url, string? altText = "", string? title = "", int? width = null, int? height = null, bool lazyLoad = true)
        {
            if (string.IsNullOrEmpty(url))
            {
                return string.Empty;
            }
            
            var webpUrl = ConvertToWebP(url);
            var srcset = width.HasValue ? GenerateSrcSet(url, null, width.Value) : string.Empty;
            
            var html = new StringBuilder();
            
            html.AppendLine("<picture>");
            html.AppendLine($"  <source srcset=\"{webpUrl}\" type=\"image/webp\">");
            
            if (!string.IsNullOrEmpty(srcset))
            {
                html.AppendLine($"  <source srcset=\"{srcset}\">");
            }
            
            html.Append($"  <img src=\"{url}\"");
            
            if (!string.IsNullOrEmpty(altText))
            {
                html.Append($" alt=\"{altText}\"");
            }
            
            if (!string.IsNullOrEmpty(title))
            {
                html.Append($" title=\"{title}\"");
            }
            
            if (lazyLoad)
            {
                html.Append(" loading=\"lazy\" decoding=\"async\"");
            }
            
            html.Append(" class=\"optimized-image\"");
            
            if (width.HasValue)
            {
                html.Append($" width=\"{width}\"");
            }
            
            if (height.HasValue)
            {
                html.Append($" height=\"{height}\"");
            }
            
            html.AppendLine(">");
            html.AppendLine("</picture>");
            
            return html.ToString();
        }

        public string ConvertToWebP(string? url)
        {
            if (string.IsNullOrEmpty(url))
            {
                return string.Empty;
            }
            
            return url.Contains("?") ? $"{url}&format=webp" : $"{url}?format=webp";
        }

        public string GenerateSrcSet(string? url, string? cropAlias, int baseWidth)
        {
            if (string.IsNullOrEmpty(url))
            {
                return string.Empty;
            }
            
            var srcset = new List<string>();
            var multipliers = new[] { 1, 1.5, 2, 3 };
            
            foreach (var multiplier in multipliers)
            {
                var width = (int)(baseWidth * multiplier);
                var resizedUrl = url.Contains("?") 
                    ? $"{url}&width={width}" 
                    : $"{url}?width={width}";
                srcset.Add($"{resizedUrl} {multiplier}x");
            }
            
            return string.Join(", ", srcset);
        }
    }
} 
 
/StaticCssGeneratorService.cs: 
using Microsoft.AspNetCore.Hosting;
using System.Text;
using System.Text.RegularExpressions;
using Umbraco.Cms.Core.Services;
using Umbraco.Cms.Core.Models;
using System.Collections.Concurrent;
using Umbraco.Extensions;

namespace TestUmbraco.Services
{
    public class StaticCssGeneratorService : IStaticCssGeneratorService
    {
        private readonly IWebHostEnvironment _env;
        private readonly IMediaService _mediaService;
        private readonly IMediaCacheService _mediaCacheService;
        private readonly ILoggingService _loggingService;
        private readonly string _cssFilePath;
        private readonly ConcurrentDictionary<string, string> _styleCache = new();
        private readonly object _fileLock = new();

        public StaticCssGeneratorService(
            IWebHostEnvironment env,
            IMediaService mediaService,
            IMediaCacheService mediaCacheService,
            ILoggingService loggingService)
        {
            _env = env;
            _mediaService = mediaService;
            _mediaCacheService = mediaCacheService;
            _loggingService = loggingService;
            
            // Путь к статическому CSS файлу
            _cssFilePath = Path.Combine(_env.WebRootPath, "css", "backgrounds.css");
            
            // Создаем директорию если её нет
            var cssDir = Path.GetDirectoryName(_cssFilePath);
            if (!Directory.Exists(cssDir))
            {
                Directory.CreateDirectory(cssDir!);
            }
        }

        public async Task<string> GenerateBackgroundCssFileAsync()
        {
            lock (_fileLock)
            {
                try
                {
                    var cssBuilder = new StringBuilder();
                    
                    // Заголовок файла
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine("/* BACKGROUNDS.CSS - STATIC BACKGROUND STYLES  */");
                    cssBuilder.AppendLine("/* Generated: " + DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss") + " UTC */");
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine();
                    
                    // Глобальные стили для фонов
                    cssBuilder.AppendLine("/* === GLOBAL BACKGROUND CLASSES === */");
                    cssBuilder.AppendLine(".lazy-bg {");
                    cssBuilder.AppendLine("  position: relative;");
                    cssBuilder.AppendLine("  overflow: hidden;");
                    cssBuilder.AppendLine("}");
                    cssBuilder.AppendLine();
                    
                    cssBuilder.AppendLine(".with-overlay {");
                    cssBuilder.AppendLine("  position: relative;");
                    cssBuilder.AppendLine("}");
                    cssBuilder.AppendLine();
                    
                    cssBuilder.AppendLine(".background-overlay {");
                    cssBuilder.AppendLine("  content: '';");
                    cssBuilder.AppendLine("  position: absolute;");
                    cssBuilder.AppendLine("  top: 0;");
                    cssBuilder.AppendLine("  left: 0;");
                    cssBuilder.AppendLine("  width: 100%;");
                    cssBuilder.AppendLine("  height: 100%;");
                    cssBuilder.AppendLine("  z-index: 1;");
                    cssBuilder.AppendLine("  pointer-events: none;");
                    cssBuilder.AppendLine("}");
                    cssBuilder.AppendLine();
                    
                    // Стили для видео фонов
                    cssBuilder.AppendLine("/* === VIDEO BACKGROUND CLASSES === */");
                    cssBuilder.AppendLine(".lazy-video {");
                    cssBuilder.AppendLine("  position: relative;");
                    cssBuilder.AppendLine("  min-height: 400px;");
                    cssBuilder.AppendLine("  overflow: hidden;");
                    cssBuilder.AppendLine("}");
                    cssBuilder.AppendLine();
                    
                    cssBuilder.AppendLine(".lazy-video .video-container {");
                    cssBuilder.AppendLine("  position: absolute;");
                    cssBuilder.AppendLine("  top: 0;");
                    cssBuilder.AppendLine("  left: 0;");
                    cssBuilder.AppendLine("  width: 100%;");
                    cssBuilder.AppendLine("  height: 100%;");
                    cssBuilder.AppendLine("  z-index: 0;");
                    cssBuilder.AppendLine("  pointer-events: none;");
                    cssBuilder.AppendLine("}");
                    cssBuilder.AppendLine();
                    
                    cssBuilder.AppendLine(".lazy-video .video-bg-iframe {");
                    cssBuilder.AppendLine("  position: absolute;");
                    cssBuilder.AppendLine("  top: 50%;");
                    cssBuilder.AppendLine("  left: 50%;");
                    cssBuilder.AppendLine("  width: 177.77777778vh;");
                    cssBuilder.AppendLine("  min-width: 100%;");
                    cssBuilder.AppendLine("  min-height: 100%;");
                    cssBuilder.AppendLine("  height: 56.25vw;");
                    cssBuilder.AppendLine("  transform: translate(-50%, -50%);");
                    cssBuilder.AppendLine("  border: 0;");
                    cssBuilder.AppendLine("  z-index: 0;");
                    cssBuilder.AppendLine("  pointer-events: none;");
                    cssBuilder.AppendLine("}");
                    cssBuilder.AppendLine();
                    
                    cssBuilder.AppendLine(".lazy-video .video-placeholder {");
                    cssBuilder.AppendLine("  background-size: cover;");
                    cssBuilder.AppendLine("  background-position: center;");
                    cssBuilder.AppendLine("  position: absolute;");
                    cssBuilder.AppendLine("  top: 0;");
                    cssBuilder.AppendLine("  left: 0;");
                    cssBuilder.AppendLine("  width: 100%;");
                    cssBuilder.AppendLine("  height: 100%;");
                    cssBuilder.AppendLine("  z-index: -1;");
                    cssBuilder.AppendLine("}");
                    cssBuilder.AppendLine();
                    
                    // Секция для медиа классов
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine("/* MEDIA BACKGROUND CLASSES                   */");
                    cssBuilder.AppendLine("/* Auto-generated from Umbraco media library  */");
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine();
                    
                    // Секция для цветовых классов
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine("/* COLOR BACKGROUND CLASSES                   */");
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine();
                    
                    // Секция для градиентных классов
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine("/* GRADIENT BACKGROUND CLASSES                */");
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine();
                    
                    // Секция для оверлейных классов
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine("/* OVERLAY STYLES                             */");
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine();
                    
                    // Секция для пользовательских стилей (min-height и другие инлайновые)
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine("/* CUSTOM INLINE STYLES                       */");
                    cssBuilder.AppendLine("/* =========================================== */");
                    cssBuilder.AppendLine();
                    
                    var cssContent = cssBuilder.ToString();
                    
                    // Используем полное имя System.IO.File для устранения неоднозначности
                    System.IO.File.WriteAllText(_cssFilePath, cssContent, Encoding.UTF8);
                    
                    _loggingService.LogInformation<StaticCssGeneratorService>($"Static CSS file generated: {_cssFilePath}");
                    return _cssFilePath;
                }
                catch (Exception ex)
                {
                    _loggingService.LogError<StaticCssGeneratorService>("Error generating static CSS file", ex);
                    throw;
                }
            }
        }

        public async Task UpdateCssForMediaAsync(Guid mediaKey)
        {
            try
            {
                var media = _mediaService.GetById(mediaKey);
                if (media == null) return;
                
                var url = await _mediaCacheService.GetCachedMediaUrlAsync(mediaKey);
                if (string.IsNullOrEmpty(url)) return;
                
                var mediaHash = GetMediaHash(mediaKey, url);
                
                // Генерируем CSS для этого медиа
                var css = GenerateMediaCss(mediaKey, url);
                
                // Добавляем в файл
                await AppendOrUpdateCssSectionAsync($"media_{mediaKey:N}", css, "MEDIA BACKGROUND CLASSES");
                
                _loggingService.LogInformation<StaticCssGeneratorService>($"Updated CSS for media: {mediaKey}");
            }
            catch (Exception ex)
            {
                _loggingService.LogError<StaticCssGeneratorService>($"Error updating CSS for media {mediaKey}", ex);
            }
        }

        public async Task RemoveCssForMediaAsync(Guid mediaKey)
        {
            try
            {
                await RemoveCssSectionAsync($"media_{mediaKey:N}");
                _loggingService.LogInformation<StaticCssGeneratorService>($"Removed CSS for media: {mediaKey}");
            }
            catch (Exception ex)
            {
                _loggingService.LogError<StaticCssGeneratorService>($"Error removing CSS for media {mediaKey}", ex);
            }
        }

        public async Task RegenerateAllCssAsync()
        {
            try
            {
                // Сначала генерируем базовый файл
                await GenerateBackgroundCssFileAsync();
                
                // Получаем все медиа элементы - исправленная версия
                var allMedia = GetAllMediaItems();
                
                foreach (var media in allMedia)
                {
                    await UpdateCssForMediaAsync(media.Key);
                }
                
                _loggingService.LogInformation<StaticCssGeneratorService>("Regenerated all CSS backgrounds");
            }
            catch (Exception ex)
            {
                _loggingService.LogError<StaticCssGeneratorService>("Error regenerating all CSS", ex);
            }
        }

        public async Task<string> AddInlineStyleAsync(string css, string styleType = "custom")
        {
            var hash = ComputeHash(css);
            var className = $"{styleType}-{hash}";
            
            // Проверяем, есть ли уже такой стиль
            if (!_styleCache.ContainsKey(className))
            {
                _styleCache[className] = css;
                
                // Определяем секцию в зависимости от типа стиля
                string sectionName;
                switch (styleType.ToLower())
                {
                    case "video":
                        sectionName = "VIDEO BACKGROUND CLASSES";
                        break;
                    case "overlay":
                        sectionName = "OVERLAY STYLES";
                        break;
                    case "minheight":
                        sectionName = "CUSTOM INLINE STYLES";
                        // Для min-height генерируем класс
                        var minHeightMatch = Regex.Match(css, @"min-height:\s*(\d+)px");
                        if (minHeightMatch.Success)
                        {
                            var height = minHeightMatch.Groups[1].Value;
                            className = $"min-h-{height}";
                            css = $".{className} {{ {css} }}";
                        }
                        break;
                    default:
                        sectionName = "CUSTOM INLINE STYLES";
                        // Оборачиваем CSS в класс, если это не уже обернуто
                        if (!css.Trim().StartsWith("."))
                        {
                            css = $".{className} {{ {css} }}";
                        }
                        break;
                }
                
                await AppendOrUpdateCssSectionAsync(className, css, sectionName);
            }
            
            return className;
        }

        public async Task<string> GetOrAddMediaClassAsync(Guid mediaKey, string className, int minHeight = 400, string size = "cover", string position = "center")
        {
            var url = await _mediaCacheService.GetCachedMediaUrlAsync(mediaKey);
            if (string.IsNullOrEmpty(url)) return string.Empty;
            
            // Генерируем CSS
            var css = $@"
.{className} {{
    background-image: url('{url}');
    background-size: {size};
    background-position: {position};
    background-repeat: no-repeat;
    min-height: {minHeight}px;
}}";
            
            // Добавляем в файл
            var sectionId = $"media_{mediaKey:N}_{GetHash(className)}";
            await AppendOrUpdateCssSectionAsync(sectionId, css, "MEDIA BACKGROUND CLASSES");
            
            return className;
        }

        public async Task<string> GetOrAddColorClassAsync(string colorValue, int minHeight = 400)
        {
            var hash = ComputeHash($"color:{colorValue}:{minHeight}");
            var className = $"bg-color-{hash}";
            
            var css = $@"
.{className} {{
    background-color: {colorValue};
    min-height: {minHeight}px;
    position: relative;
}}";
            
            await AppendOrUpdateCssSectionAsync(className, css, "COLOR BACKGROUND CLASSES");
            
            return className;
        }

        public async Task<string> GetOrAddGradientClassAsync(string colorStart, string colorEnd, string direction = "to bottom", int minHeight = 400)
        {
            var hash = ComputeHash($"gradient:{colorStart}:{colorEnd}:{direction}:{minHeight}");
            var className = $"bg-gradient-{hash}";
            
            var css = $@"
.{className} {{
    background: linear-gradient({direction}, {colorStart}, {colorEnd});
    min-height: {minHeight}px;
    position: relative;
}}";
            
            await AppendOrUpdateCssSectionAsync(className, css, "GRADIENT BACKGROUND CLASSES");
            
            return className;
        }

        public async Task<string> AddOverlayStyleAsync(string overlayClass, string css)
        {
            // Добавляем префикс, чтобы стили оверлея были уникальными
            var sectionId = $"overlay_{overlayClass}";
            
            // Оборачиваем CSS в класс, если это не уже обернуто
            if (!css.Trim().StartsWith("."))
            {
                // Ищем уже существующие классы оверлея и добавляем к ним
                var overlayClassMatch = Regex.Match(css, @"\.([\w\-]+)\s*\.background-overlay");
                if (overlayClassMatch.Success)
                {
                    // CSS уже содержит правильный класс
                }
                else
                {
                    // Добавляем класс оверлея
                    css = $".{overlayClass} .background-overlay {{ {css} }}";
                }
            }
            
            await AppendOrUpdateCssSectionAsync(sectionId, css, "OVERLAY STYLES");
            return overlayClass;
        }

        private async Task AppendOrUpdateCssSectionAsync(string sectionId, string css, string sectionName)
        {
            lock (_fileLock)
            {
                try
                {
                    if (!System.IO.File.Exists(_cssFilePath))
                    {
                        GenerateBackgroundCssFileAsync().Wait();
                    }
                    
                    var content = System.IO.File.ReadAllText(_cssFilePath);
                    
                    // Ищем секцию по имени
                    var escapedSectionName = Regex.Escape(sectionName);
                    var sectionPattern = $@"\/\*\s*={{{escapedSectionName}}}\s*\*\/.*?(?=\/\*\s*=|\Z)";
                    var sectionMatch = Regex.Match(content, sectionPattern, RegexOptions.Singleline | RegexOptions.IgnoreCase);
                    
                    if (sectionMatch.Success)
                    {
                        var sectionContent = sectionMatch.Value;
                        
                        // Ищем подсекцию с нашим ID
                        var subsectionPattern = $@"\/\*\s*{Regex.Escape(sectionId)}\s*\*\/.*?(?=\/\*\s*\w+|$)";
                        var subsectionMatch = Regex.Match(sectionContent, subsectionPattern, RegexOptions.Singleline);
                        
                        if (subsectionMatch.Success)
                        {
                            // Обновляем существующую подсекцию
                            var updatedSectionContent = Regex.Replace(
                                sectionContent,
                                Regex.Escape(subsectionMatch.Value),
                                $"/* {sectionId} */\n{css}\n",
                                RegexOptions.Singleline);
                            
                            content = content.Replace(sectionMatch.Value, updatedSectionContent);
                        }
                        else
                        {
                            // Добавляем новую подсекцию в конец секции
                            var updatedSectionContent = sectionContent.TrimEnd() + $"\n\n/* {sectionId} */\n{css}\n";
                            content = content.Replace(sectionMatch.Value, updatedSectionContent);
                        }
                    }
                    else
                    {
                        // Секция не найдена, добавляем новую
                        var newSection = $"\n\n/* =========================================== */\n" +
                                       $"/* {sectionName.PadRight(40)} */\n" +
                                       $"/* =========================================== */\n" +
                                       $"\n/* {sectionId} */\n{css}\n";
                        
                        content += newSection;
                    }
                    
                    System.IO.File.WriteAllText(_cssFilePath, content, Encoding.UTF8);
                }
                catch (Exception ex)
                {
                    _loggingService.LogError<StaticCssGeneratorService>($"Error appending CSS section: {sectionId}", ex);
                    throw;
                }
            }
        }

        private async Task RemoveCssSectionAsync(string sectionId)
        {
            lock (_fileLock)
            {
                try
                {
                    if (!System.IO.File.Exists(_cssFilePath)) return;
                    
                    var content = System.IO.File.ReadAllText(_cssFilePath);
                    
                    // Ищем и удаляем подсекцию с нашим ID
                    var pattern = $@"\/\*\s*{Regex.Escape(sectionId)}\s*\*\/.*?(?=\/\*\s*\w+|$)";
                    content = Regex.Replace(content, pattern, "", RegexOptions.Singleline);
                    
                    // Удаляем пустые строки
                    content = Regex.Replace(content, @"^\s*$\n", "", RegexOptions.Multiline);
                    
                    System.IO.File.WriteAllText(_cssFilePath, content, Encoding.UTF8);
                }
                catch (Exception ex)
                {
                    _loggingService.LogError<StaticCssGeneratorService>($"Error removing CSS section: {sectionId}", ex);
                    throw;
                }
            }
        }

        private string GenerateMediaCss(Guid mediaKey, string url)
        {
            var baseClass = $"bg-media-{mediaKey:N}";
            
            return $@"/* {mediaKey} */
.{baseClass} {{
    background-image: url('{url}');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
}}

.{baseClass}-contain {{
    background-image: url('{url}');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
}}";
        }

        private string GetMediaHash(Guid mediaKey, string url)
        {
            using var md5 = System.Security.Cryptography.MD5.Create();
            var input = $"{mediaKey}:{url}";
            var hash = md5.ComputeHash(Encoding.UTF8.GetBytes(input));
            return BitConverter.ToString(hash).Replace("-", "").ToLower().Substring(0, 8);
        }

        private string ComputeHash(string input)
        {
            using var md5 = System.Security.Cryptography.MD5.Create();
            var hash = md5.ComputeHash(Encoding.UTF8.GetBytes(input));
            return BitConverter.ToString(hash).Replace("-", "").ToLower().Substring(0, 8);
        }

        private string GetHash(string input)
        {
            return ComputeHash(input);
        }

        private List<IMedia> GetAllMediaItems()
        {
            var allMedia = new List<IMedia>();
            
            try
            {
                // Получаем корневые медиа
                var rootMedia = _mediaService.GetRootMedia().ToList();
                
                foreach (var media in rootMedia)
                {
                    allMedia.Add(media);
                    // Рекурсивно получаем дочерние элементы
                    GetDescendants(media, ref allMedia);
                }
            }
            catch (Exception ex)
            {
                _loggingService.LogError<StaticCssGeneratorService>("Error getting all media items", ex);
            }
            
            return allMedia;
        }

        private void GetDescendants(IMedia parent, ref List<IMedia> allMedia)
        {
            try
            {
                // Используем GetPagedChildren с большим размером страницы, чтобы получить всех детей
                long totalRecords;
                var children = _mediaService.GetPagedChildren(parent.Id, 0, int.MaxValue, out totalRecords).ToList();
                
                foreach (var child in children)
                {
                    allMedia.Add(child);
                    GetDescendants(child, ref allMedia);
                }
            }
            catch (Exception ex)
            {
                _loggingService.LogError<StaticCssGeneratorService>($"Error getting descendants for media {parent.Id}", ex);
            }
        }
    }
} 
 
/UmbracoBackgroundService.cs: 
using Microsoft.AspNetCore.Http;
using System.Text;
using System.Text.RegularExpressions;
using Umbraco.Cms.Core.Models.PublishedContent;

namespace TestUmbraco.Services
{
    public class UmbracoBackgroundService : IUmbracoBackgroundService
    {
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly ILoggingService _loggingService;
        private readonly IMediaCacheService _mediaCacheService;
        private readonly IStaticCssGeneratorService _staticCssGenerator;

        public UmbracoBackgroundService(
            IHttpContextAccessor httpContextAccessor,
            ILoggingService loggingService,
            IMediaCacheService mediaCacheService,
            IStaticCssGeneratorService staticCssGenerator)
        {
            _httpContextAccessor = httpContextAccessor;
            _loggingService = loggingService;
            _mediaCacheService = mediaCacheService;
            _staticCssGenerator = staticCssGenerator;
        }

        public async Task<BackgroundResult> ProcessBackground(IPublishedElement? settings, Guid componentId, string prefix = "bg")
        {
            var result = new BackgroundResult();
            
            if (settings == null) return result;

            if (settings.HasProperty("bg") && settings.HasValue("bg"))
            {
                var bgValue = settings.Value<string>("bg");
                if (!string.IsNullOrWhiteSpace(bgValue))
                {
                    result = await ProcessBackgroundType(settings, componentId, prefix, bgValue);
                    
                    // Обработка оверлея
                    if (result.HasBackground && settings.HasProperty("overlayBg") && settings.HasValue("overlayBg"))
                    {
                        var overlayBgValue = settings.Value<string>("overlayBg");
                        if (!string.IsNullOrWhiteSpace(overlayBgValue) && overlayBgValue != "Не выбран" && overlayBgValue != "None")
                        {
                            result.HasOverlay = true;
                            result.OverlayClass = $"overlay-{componentId:N}";
                            result.CssClass += $" {result.OverlayClass}";
                            await AddOverlayStyles(settings, componentId, result.OverlayClass);
                        }
                    }
                    
                    // Регистрируем информацию для JavaScript
                    RegisterBackgroundInfo(settings, componentId, result, bgValue);
                }
            }
            
            return result;
        }

        private async Task<BackgroundResult> ProcessBackgroundType(IPublishedElement settings, Guid componentId, string prefix, string bgValue)
        {
            BackgroundResult result;
            
            var trimmedValue = bgValue.Trim();
            
            switch (trimmedValue)
            {
                case "Изображение":
                    result = await ProcessImageBackground(settings, componentId, prefix);
                    break;
                case "Цвет":
                    result = await ProcessColorBackground(settings, componentId, prefix);
                    break;
                case "Градиент":
                    result = await ProcessGradientBackground(settings, componentId, prefix);
                    break;
                case "Видео":
                    result = await ProcessVideoBackground(settings, componentId, prefix);
                    break;
                default:
                    result = new BackgroundResult();
                    break;
            }
            
            return result;
        }

        private async Task<BackgroundResult> ProcessImageBackground(IPublishedElement settings, Guid componentId, string prefix)
        {
            var result = new BackgroundResult { Type = BackgroundType.Image };
            
            if (settings.HasProperty("backgroundImage") && settings.HasValue("backgroundImage"))
            {
                var bgImage = settings.Value<IPublishedContent>("backgroundImage");
                if (bgImage != null)
                {
                    var minHeight = settings.HasValue("minHeight") ? settings.Value<int>("minHeight") : 400;
                    var bgSize = settings.HasValue("bgSize") ? 
                        ConvertBgSizeToCss(settings.Value<string>("bgSize") ?? "") : "cover";
                    var bgPosition = settings.HasValue("backgroundPosition") ? 
                        settings.Value<string>("backgroundPosition") ?? "center" : "center";
                    
                    // Генерируем класс через статический CSS сервис
                    var className = $"bg-media-{bgImage.Key:N}";
                    if (bgSize == "contain")
                    {
                        className += "-contain";
                    }
                    
                    // Добавляем стиль в статический CSS файл
                    await _staticCssGenerator.GetOrAddMediaClassAsync(
                        bgImage.Key, 
                        className, 
                        minHeight, 
                        bgSize, 
                        bgPosition);
                    
                    result.CssClass = $"{className} lazy-bg";
                    result.HasBackground = true;
                    result.IsLazyLoaded = true;
                    
                    // Добавляем инлайновые стили для min-height
                    if (minHeight > 0)
                    {
                        var minHeightClass = $"min-h-{minHeight}";
                        await _staticCssGenerator.AddInlineStyleAsync($"min-height: {minHeight}px;", "minheight");
                        result.CssClass += $" {minHeightClass}";
                    }
                }
            }
            
            return result;
        }

        private async Task<BackgroundResult> ProcessColorBackground(IPublishedElement settings, Guid componentId, string prefix)
        {
            var result = new BackgroundResult { Type = BackgroundType.Color };
            
            if (settings.HasProperty("color") && settings.HasValue("color"))
            {
                var color = settings.Value<string>("color");
                if (!string.IsNullOrWhiteSpace(color))
                {
                    var minHeight = settings.HasValue("minHeight") ? settings.Value<int>("minHeight") : 400;
                    
                    // Генерируем класс через статический CSS сервис
                    var className = await _staticCssGenerator.GetOrAddColorClassAsync(color, minHeight);
                    
                    result.CssClass = className;
                    result.HasBackground = true;
                }
            }
            
            return result;
        }

        private async Task<BackgroundResult> ProcessGradientBackground(IPublishedElement settings, Guid componentId, string prefix)
        {
            var result = new BackgroundResult { Type = BackgroundType.Gradient };
            
            if (settings.HasProperty("colorStart") && settings.HasValue("colorStart") &&
                settings.HasProperty("colorEnd") && settings.HasValue("colorEnd"))
            {
                var colorStart = settings.Value<string>("colorStart");
                var colorEnd = settings.Value<string>("colorEnd");
                
                if (!string.IsNullOrWhiteSpace(colorStart) && !string.IsNullOrWhiteSpace(colorEnd))
                {
                    var direction = "to bottom";
                    if (settings.HasProperty("direction") && settings.HasValue("direction"))
                    {
                        direction = ConvertDirectionToCss(settings.Value<string>("direction") ?? "");
                    }
                    
                    var minHeight = settings.HasValue("minHeight") ? settings.Value<int>("minHeight") : 400;
                    
                    // Генерируем класс через статический CSS сервис
                    var className = await _staticCssGenerator.GetOrAddGradientClassAsync(
                        colorStart, colorEnd, direction, minHeight);
                    
                    result.CssClass = className;
                    result.HasBackground = true;
                }
            }
            
            return result;
        }

        private async Task<BackgroundResult> ProcessVideoBackground(IPublishedElement settings, Guid componentId, string prefix)
        {
            var result = new BackgroundResult { Type = BackgroundType.Video };
            
            if (settings.HasProperty("video") && settings.HasValue("video"))
            {
                var videoUrl = settings.Value<string>("video");
                if (!string.IsNullOrWhiteSpace(videoUrl))
                {
                    var videoId = ExtractVimeoVideoId(videoUrl);
                    if (!string.IsNullOrEmpty(videoId))
                    {
                        result.VideoId = videoId;
                        
                        var minHeight = settings.HasValue("minHeight") ? settings.Value<int>("minHeight") : 400;
                        
                        // Генерируем уникальный класс для видео
                        var videoHash = ComputeHash(videoUrl);
                        var videoClass = $"bg-video-{videoHash}";
                        
                        // Добавляем стили в статический CSS
                        var css = $@"
.{videoClass}.lazy-video {{
    position: relative;
    min-height: {minHeight}px;
    overflow: hidden;
}}

.{videoClass}.lazy-video .video-container {{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
}}

.{videoClass}.lazy-video .video-bg-iframe {{
    position: absolute;
    top: 50%;
    left: 50%;
    width: 177.77777778vh;
    min-width: 100%;
    min-height: 100%;
    height: 56.25vw;
    transform: translate(-50%, -50%);
    border: 0;
    z-index: 0;
    pointer-events: none;
}}

.{videoClass}.lazy-video .video-placeholder {{
    background-size: cover;
    background-position: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
}}";
                        
                        await _staticCssGenerator.AddInlineStyleAsync(css, "video");
                        
                        result.CssClass = $"{videoClass} lazy-video";
                        result.HasBackground = true;
                        result.IsLazyLoaded = true;
                        
                        // Проверяем наличие плейсхолдера
                        if (settings.HasProperty("videoPlaceholder") && settings.HasValue("videoPlaceholder"))
                        {
                            var placeholder = settings.Value<IPublishedContent>("videoPlaceholder");
                            if (placeholder != null)
                            {
                                var placeholderUrl = await _mediaCacheService.GetCachedMediaUrlAsync(placeholder.Key);
                                if (!string.IsNullOrEmpty(placeholderUrl))
                                {
                                    result.VideoPlaceholder = placeholderUrl;
                                    result.UseVideoPlaceholder = true;
                                }
                            }
                        }
                    }
                }
            }
            
            return result;
        }

        private async Task AddOverlayStyles(IPublishedElement settings, Guid componentId, string overlayClass)
        {
            var overlayBgValue = settings.Value<string>("overlayBg");
            
            var cssBuilder = new StringBuilder();
            
            // Исправляем подход: оверлей должен быть фоном, а не перекрытием
            cssBuilder.Append($@"
.{overlayClass} {{
    position: relative;
}}

/* Оверлей как фон - ниже всего контента */
.{overlayClass}::before {{
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;  // < ИСПРАВЛЕНО: было 1, стало 0
    pointer-events: none;
}}");
            
            // Обрабатываем тип оверлея
            switch (overlayBgValue)
            {
                case "Цвет":
                    if (settings.HasProperty("colorOverlay") && settings.HasValue("colorOverlay"))
                    {
                        var color = settings.Value<string>("colorOverlay");
                        if (!string.IsNullOrWhiteSpace(color))
                        {
                            cssBuilder.Append($@"
.{overlayClass}::before {{
    background-color: {color};
}}");
                        }
                    }
                    break;
                    
                case "Изображение":
                    if (settings.HasProperty("imageOverlay") && settings.HasValue("imageOverlay"))
                    {
                        var image = settings.Value<IPublishedContent>("imageOverlay");
                        if (image != null)
                        {
                            var imageUrl = await _mediaCacheService.GetCachedMediaUrlAsync(image.Key);
                            if (!string.IsNullOrEmpty(imageUrl))
                            {
                                cssBuilder.Append($@"
.{overlayClass}::before {{
    background-image: url('{imageUrl}');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
}}");
                            }
                        }
                    }
                    break;
                    
                case "Градиент":
                    if (settings.HasProperty("colorStartOverlay") && settings.HasValue("colorStartOverlay") &&
                        settings.HasProperty("colorEndOverlay") && settings.HasValue("colorEndOverlay"))
                    {
                        var colorStart = settings.Value<string>("colorStartOverlay");
                        var colorEnd = settings.Value<string>("colorEndOverlay");
                        
                        if (!string.IsNullOrWhiteSpace(colorStart) && !string.IsNullOrWhiteSpace(colorEnd))
                        {
                            // Получаем направление градиента
                            var direction = "to bottom";
                            if (settings.HasProperty("directionOverlay") && settings.HasValue("directionOverlay"))
                            {
                                direction = ConvertDirectionToCss(settings.Value<string>("directionOverlay") ?? "");
                            }
                            
                            cssBuilder.Append($@"
.{overlayClass}::before {{
    background: linear-gradient({direction}, {colorStart}, {colorEnd});
}}");
                        }
                    }
                    break;
            }
            
            // Прозрачность оверлея
            if (settings.HasProperty("opacityOverlay") && settings.HasValue("opacityOverlay"))
            {
                var opacityValue = settings.Value<int>("opacityOverlay");
                var opacity = opacityValue / 100.0;
                cssBuilder.Append($@"
.{overlayClass}::before {{
    opacity: {opacity.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture)};
}}");
            }
            
            // Добавляем стили для поднятия контента над оверлеем
            cssBuilder.Append($@"
/* Поднимаем контент над оверлеем */
.{overlayClass} > .cmt,
.{overlayClass} > [class*=""container""] {{
    position: relative;
    z-index: 2;
}}

/* Особенно изображения и карточки */
.{overlayClass} .image-wrapper,
.{overlayClass} .card,
.{overlayClass} img {{
    position: relative;
    z-index: 2 !important;
}}");
            
            await _staticCssGenerator.AddInlineStyleAsync(cssBuilder.ToString(), "overlay");
        }

        private void RegisterBackgroundInfo(IPublishedElement settings, Guid componentId, BackgroundResult result, string bgValue)
        {
            var httpContext = _httpContextAccessor.HttpContext;
            if (httpContext == null) return;

            var backgroundInfos = httpContext.Items["LazyBackgroundsInfo"] as List<BackgroundInfo> ?? new List<BackgroundInfo>();
            
            var info = new BackgroundInfo
            {
                ComponentClass = result.CssClass,
                Type = bgValue,
                ComponentId = componentId.ToString(),
                HasOverlay = result.HasOverlay,
                OverlayClass = result.OverlayClass
            };
            
            switch (bgValue.Trim())
            {
                case "Изображение":
                    if (settings.HasProperty("backgroundImage") && settings.HasValue("backgroundImage"))
                    {
                        var bgImage = settings.Value<IPublishedContent>("backgroundImage");
                        if (bgImage != null)
                        {
                            info.Url = _mediaCacheService.GetCachedMediaUrlAsync(bgImage.Key).GetAwaiter().GetResult() ?? string.Empty;
                            info.Size = settings.HasValue("bgSize") ? 
                                ConvertBgSizeToCss(settings.Value<string>("bgSize") ?? "") : "cover";
                            info.Position = settings.HasValue("backgroundPosition") ? 
                                settings.Value<string>("backgroundPosition") ?? "center" : "center";
                        }
                    }
                    break;
                    
                case "Видео":
                    if (settings.HasProperty("video") && settings.HasValue("video"))
                    {
                        var videoUrl = settings.Value<string>("video");
                        if (!string.IsNullOrWhiteSpace(videoUrl))
                        {
                            var videoId = ExtractVimeoVideoId(videoUrl);
                            if (!string.IsNullOrEmpty(videoId))
                            {
                                info.VideoId = videoId;
                                
                                if (settings.HasProperty("videoPlaceholder") && settings.HasValue("videoPlaceholder"))
                                {
                                    var placeholder = settings.Value<IPublishedContent>("videoPlaceholder");
                                    if (placeholder != null)
                                    {
                                        info.PlaceholderUrl = _mediaCacheService.GetCachedMediaUrlAsync(placeholder.Key).GetAwaiter().GetResult() ?? string.Empty;
                                        info.UsePlaceholder = true;
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
            
            backgroundInfos.Add(info);
            httpContext.Items["LazyBackgroundsInfo"] = backgroundInfos;
        }

        private string ConvertBgSizeToCss(string bgSizeValue)
        {
            if (string.IsNullOrWhiteSpace(bgSizeValue))
                return "cover";
            
            var trimmedValue = bgSizeValue.Trim();
            
            return trimmedValue switch
            {
                "Как есть" => "auto",
                "По ширине" => "100% auto",
                "По высоте" => "auto 100%",
                "Обложка" => "cover",
                "Вместить" => "contain",
                _ => "cover"
            };
        }

        private string ConvertDirectionToCss(string directionValue)
        {
            if (string.IsNullOrWhiteSpace(directionValue))
                return "to bottom";
            
            var trimmedValue = directionValue.Trim();
            
            return trimmedValue switch
            {
                "Сверху вниз" => "to bottom",
                "Снизу вверх" => "to top",
                "Слева направо" => "to right",
                "Справа налево" => "to left",
                "Диагональ (?)" => "to bottom right",
                "Диагональ (?)" => "to bottom left",
                "Диагональ (?)" => "to top right",
                "Диагональ (?)" => "to top left",
                _ => "to bottom"
            };
        }

        private string? ExtractVimeoVideoId(string url)
        {
            if (string.IsNullOrWhiteSpace(url))
                return null;
            
            url = url.Split('?')[0];
            var regex = new Regex(@"vimeo\.com/(?:.*/)?(\d+)");
            var match = regex.Match(url);
            
            return match.Success && match.Groups.Count > 1 ? match.Groups[1].Value : null;
        }

        private string ComputeHash(string input)
        {
            using var md5 = System.Security.Cryptography.MD5.Create();
            var hash = md5.ComputeHash(Encoding.UTF8.GetBytes(input));
            return BitConverter.ToString(hash).Replace("-", "").ToLower().Substring(0, 8);
        }
    }
} 
 
