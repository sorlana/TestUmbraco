Для фоновых изображений:

---------------------------------------------------
// Controllers/UniversalBackgroundController.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using System.Text;
using Umbraco.Cms.Core.Services;
using Umbraco.Cms.Core.Web;

namespace TestUmbraco.Controllers
{
    [Route("api/background")]
    [ApiController]
    public class UniversalBackgroundController : ControllerBase
    {
        private readonly IMemoryCache _memoryCache;
        private readonly ILogger<UniversalBackgroundController> _logger;
        private readonly IUmbracoContextAccessor _umbracoContextAccessor;
        private readonly IMediaService _mediaService;

        public UniversalBackgroundController(
            IMemoryCache memoryCache,
            ILogger<UniversalBackgroundController> logger,
            IUmbracoContextAccessor umbracoContextAccessor,
            IMediaService mediaService)
        {
            _memoryCache = memoryCache;
            _logger = logger;
            _umbracoContextAccessor = umbracoContextAccessor;
            _mediaService = mediaService;
        }

        [HttpGet("multiple")]
        public IActionResult GetMultipleCss([FromQuery] string backgrounds)
        {
            if (string.IsNullOrEmpty(backgrounds))
            {
                return Content("/* No backgrounds specified */", "text/css");
            }

            var cacheKey = $"BgCss_Multiple_{backgrounds.GetHashCode()}";
            
            if (_memoryCache.TryGetValue(cacheKey, out string? cachedCss))
            {
                return Content(cachedCss ?? string.Empty, "text/css");
            }

            var cssBuilder = new StringBuilder();
            var processedCount = 0;
            
            try
            {
                var backgroundItems = backgrounds.Split('|', StringSplitOptions.RemoveEmptyEntries);
                
                foreach (var item in backgroundItems)
                {
                    var parts = item.Split(':');
                    
                    if (parts.Length >= 2)
                    {
                        var mediaGuidStr = parts[0];
                        var className = parts[1];
                        var minHeight = parts.Length > 2 && int.TryParse(parts[2], out var mh) ? mh : 400;
                        var size = parts.Length > 3 ? parts[3] : "cover";
                        var position = parts.Length > 4 ? parts[4] : "center";

                        if (Guid.TryParse(mediaGuidStr, out Guid mediaGuid) && mediaGuid != Guid.Empty)
                        {
                            var mediaUrl = GetMediaUrl(mediaGuid);
                            
                            cssBuilder.AppendLine($".{className} {{");
                            cssBuilder.AppendLine($"  background-image: url('{mediaUrl}');");
                            cssBuilder.AppendLine($"  background-size: {size};");
                            cssBuilder.AppendLine($"  background-position: {position};");
                            cssBuilder.AppendLine($"  background-repeat: no-repeat;");
                            cssBuilder.AppendLine($"  min-height: {minHeight}px;");
                            cssBuilder.AppendLine("}}");
                            cssBuilder.AppendLine();
                            
                            processedCount++;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating background CSS");
                return Content("/* Error generating CSS */", "text/css");
            }

            var css = cssBuilder.ToString();
            
            if (string.IsNullOrWhiteSpace(css))
            {
                css = "/* No valid backgrounds generated */";
            }
            
            _memoryCache.Set(cacheKey, css, TimeSpan.FromHours(1));
            
            return Content(css, "text/css");
        }

        private string GetMediaUrl(Guid mediaGuid)
        {
            try
            {
                if (_umbracoContextAccessor.TryGetUmbracoContext(out var umbracoContext))
                {
                    var mediaItem = umbracoContext.Media?.GetById(mediaGuid);
                    
                    if (mediaItem != null)
                    {
                        return mediaItem.Url();
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error getting media URL");
            }
            
            // Fallback для отладки
            return GenerateFallbackImageUrl(mediaGuid);
        }

        private string GenerateFallbackImageUrl(Guid mediaGuid)
        {
            var colors = new[] { "#4CAF50", "#2196F3", "#FF9800", "#9C27B0", "#00BCD4" };
            var colorIndex = Math.Abs(mediaGuid.GetHashCode()) % colors.Length;
            var color = colors[colorIndex];
            
            var svg = $@"<svg xmlns='http://www.w3.org/2000/svg' width='1920' height='1080'>
                <rect width='100%' height='100%' fill='{color}'/>
                <text x='50%' y='50%' font-family='Arial' font-size='36' fill='white' 
                      text-anchor='middle' dy='.3em'>Background: {mediaGuid.ToString().Substring(0, 8)}</text>
            </svg>";
            
            return "data:image/svg+xml;base64," + Convert.ToBase64String(Encoding.UTF8.GetBytes(svg));
        }
    }
}


//MediaCacheController.cs
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Umbraco.Cms.Core.Cache;
using Umbraco.Cms.Core.Services;
using Microsoft.Extensions.Logging;
using Umbraco.Cms.Web.Common.Controllers;

namespace TestUmbraco.Controllers
{
    [Route("umbraco/backoffice/api/media-cache")]
    [ApiController]
    [Authorize(Policy = "BackOffice")]
    public class MediaCacheController : ControllerBase
    {
        private readonly IMediaService _mediaService;
        private readonly IAppPolicyCache _runtimeCache;
        private readonly ILogger<MediaCacheController> _logger;

        public MediaCacheController(
            IMediaService mediaService,
            AppCaches appCaches,
            ILogger<MediaCacheController> logger)
        {
            _mediaService = mediaService;
            _runtimeCache = appCaches.RuntimeCache;
            _logger = logger;
        }

        [HttpGet("info")]
        public IActionResult GetCacheInfo()
        {
            try
            {
                var cacheStats = new
                {
                    MemoryUsage = GC.GetTotalMemory(false) / 1024 / 1024 + "MB",
                    Timestamp = DateTime.UtcNow
                };
                
                return Ok(cacheStats);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting cache info");
                return StatusCode(500, new { success = false, message = ex.Message });
            }
        }

        [HttpPost("clear-for-media")]
        public IActionResult ClearCacheForMedia([FromBody] Guid mediaKey)
        {
            try
            {
                var cacheKey = $"media_{mediaKey}";
                _runtimeCache.Clear(cacheKey);
                
                _logger.LogInformation($"Cache cleared for media: {mediaKey}");
                
                return Ok(new 
                { 
                    success = true, 
                    message = $"Cache cleared for media {mediaKey}",
                    cacheKey = cacheKey
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error clearing cache for media {mediaKey}");
                return StatusCode(500, new { success = false, message = ex.Message });
            }
        }

        [HttpPost("clear-all")]
        public IActionResult ClearAllMediaCache()
        {
            try
            {
                _runtimeCache.Clear();
                
                _logger.LogInformation("Cleared all cache entries");
                
                return Ok(new 
                { 
                    success = true, 
                    message = "Cleared all cache entries"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error clearing all media cache");
                return StatusCode(500, new { success = false, message = ex.Message });
            }
        }
    }
}

// Composers/BackgroundServiceComposer.cs
using Microsoft.Extensions.DependencyInjection;
using TestUmbraco.Services;
using Umbraco.Cms.Core.Composing;
using Umbraco.Cms.Core.DependencyInjection;

namespace TestUmbraco.Composers
{
    public class BackgroundServiceComposer : IComposer
    {
        public void Compose(IUmbracoBuilder builder)
        {
            builder.Services.AddScoped<IUmbracoBackgroundService, UmbracoBackgroundService>();
            builder.Services.AddHttpContextAccessor();
        }
    }
}

// MediaCacheComposer.cs
using Umbraco.Cms.Core.Composing;
using Umbraco.Cms.Core.DependencyInjection;

namespace TestUmbraco.Composers
{
    public class MediaCacheComposer : IComposer
    {
        public void Compose(IUmbracoBuilder builder)
        {
            // В Umbraco 17 контроллеры регистрируются автоматически
            // Не нужно регистрировать контроллеры вручную
        }
    }
}

// Models/BackgroundSectionModel.cs
using Microsoft.AspNetCore.Html;
using Umbraco.Cms.Core.Models.PublishedContent;

namespace TestUmbraco.Models
{
    public class BackgroundSectionModel
    {
        public IPublishedElement? Settings { get; set; } // Делаем nullable
        public Guid ComponentId { get; set; }
        public string Prefix { get; set; } = "bg"; // Значение по умолчанию
        public string SectionClass { get; set; } = string.Empty; // Инициализация
        public Func<object, IHtmlContent>? Content { get; set; } // Делаем nullable
        public string ContainerClass { get; set; } = string.Empty; // Инициализация
    }
}

// Services/BackgroundResult.cs
namespace TestUmbraco.Services
{
    public class BackgroundResult
    {
        public BackgroundType Type { get; set; } = BackgroundType.None;
        public string CssClass { get; set; } = string.Empty;
        public bool HasBackground { get; set; }
        public bool HasOverlay { get; set; }
        public string HtmlContent { get; set; } = string.Empty;
        public bool IsLazyLoaded { get; set; }
        public bool IsMobileOptimized { get; set; }
    }

    public enum BackgroundType
    {
        None,
        Image,
        Color,
        Gradient,
        Video
    }
}

// Services/IUmbracoBackgroundService.cs
using Umbraco.Cms.Core.Models.PublishedContent;

namespace TestUmbraco.Services
{
    public interface IUmbracoBackgroundService
    {
        BackgroundResult ProcessBackground(IPublishedElement? settings, Guid componentId, string prefix = "bg");
    }
}

// Services/UmbracoBackgroundService.cs
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Umbraco.Cms.Core.Models.PublishedContent;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Linq;
using System.Text;
using TestUmbraco.Services;

namespace TestUmbraco.Services
{
    public class UmbracoBackgroundService : IUmbracoBackgroundService
    {
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly IWebHostEnvironment _env;
        private readonly ILogger<UmbracoBackgroundService> _logger;

        public UmbracoBackgroundService(
            IHttpContextAccessor httpContextAccessor, 
            IWebHostEnvironment env,
            ILogger<UmbracoBackgroundService> logger)
        {
            _httpContextAccessor = httpContextAccessor;
            _env = env;
            _logger = logger;
        }

        public BackgroundResult ProcessBackground(IPublishedElement? settings, Guid componentId, string prefix = "bg")
        {
            _logger.LogInformation($"ProcessBackground called. ComponentId: {componentId}, Prefix: {prefix}");
            
            var result = new BackgroundResult();
            
            if (settings == null)
            {
                _logger.LogWarning("Settings is null, returning empty result");
                return result;
            }

            _logger.LogDebug($"Available properties: {string.Join(", ", settings.Properties.Select(p => p.Alias))}");

            if (settings.HasProperty("bg") && settings.HasValue("bg"))
            {
                var bgValue = settings.Value<string>("bg");
                _logger.LogInformation($"Background type selected: {bgValue}");
                
                result = ProcessBackgroundType(settings, componentId, prefix, bgValue);
                _logger.LogInformation($"ProcessBackgroundType result: HasBackground={result.HasBackground}, Type={result.Type}");
                
                if (settings.HasProperty("overlayBg") && settings.HasValue("overlayBg"))
                {
                    var overlayBgValue = settings.Value<string>("overlayBg");
                    _logger.LogDebug($"Overlay background type: {overlayBgValue}");
                    
                    if (!string.IsNullOrWhiteSpace(overlayBgValue) && overlayBgValue != "Не выбрано" && overlayBgValue != "None")
                    {
                        _logger.LogInformation($"Processing overlay: {overlayBgValue}");
                        result = ProcessOverlay(settings, componentId, prefix, overlayBgValue, result);
                    }
                }
            }
            else
            {
                _logger.LogWarning("No 'bg' property or value found in settings");
            }
            
            _logger.LogInformation($"Final result: HasBackground={result.HasBackground}, CssClass={result.CssClass}");
            return result;
        }

        private BackgroundResult ProcessBackgroundType(IPublishedElement settings, Guid componentId, string prefix, string? bgValue)
        {
            var result = new BackgroundResult();
            
            if (string.IsNullOrWhiteSpace(bgValue))
            {
                _logger.LogWarning("bgValue is null or empty");
                return result;
            }
            
            var trimmedValue = bgValue.Trim();
            _logger.LogDebug($"Processing background type: {trimmedValue}");
            
            switch (trimmedValue)
            {
                case "Изображение":
                    result = ProcessOptimizedImageBackground(settings, componentId, prefix);
                    break;
                case "Цвет":
                    result = ProcessColorBackground(settings, componentId, prefix);
                    break;
                case "Градиент":
                    result = ProcessGradientBackground(settings, componentId, prefix);
                    break;
                case "Видео":
                    result = ProcessOptimizedVideoBackground(settings, componentId, prefix);
                    break;
                default:
                    _logger.LogWarning($"Unknown background type: {trimmedValue}");
                    break;
            }
            
            return result;
        }

        private BackgroundResult ProcessOverlay(IPublishedElement settings, Guid componentId, string prefix, string overlayBgValue, BackgroundResult existingResult)
        {
            if (!existingResult.HasBackground)
            {
                _logger.LogWarning("Cannot process overlay: no existing background");
                return existingResult;
            }
            
            _logger.LogDebug($"Processing overlay of type: {overlayBgValue}");
            
            var overlayCss = GenerateOverlayCss(settings, overlayBgValue, existingResult.CssClass, existingResult.Type);
            
            if (!string.IsNullOrEmpty(overlayCss))
            {
                AddToCssStyles(overlayCss);
                _logger.LogDebug("Overlay CSS added to styles");
                
                existingResult.CssClass += " with-overlay";
                _logger.LogDebug($"Updated CssClass: {existingResult.CssClass}");
            }
            else
            {
                _logger.LogWarning("Overlay CSS is empty or null");
            }
            
            existingResult.HasOverlay = !string.IsNullOrEmpty(overlayCss);
            _logger.LogInformation($"HasOverlay set to: {existingResult.HasOverlay}");
            
            return existingResult;
        }

        private BackgroundResult ProcessOptimizedImageBackground(IPublishedElement settings, Guid componentId, string prefix)
        {
            _logger.LogInformation($"Starting ProcessOptimizedImageBackground for component {componentId}");
            var result = new BackgroundResult { Type = BackgroundType.Image };
            
            if (settings.HasProperty("backgroundImage") && settings.HasValue("backgroundImage"))
            {
                var bgImage = settings.Value<IPublishedContent>("backgroundImage");
                if (bgImage != null)
                {
                    _logger.LogInformation($"Background image found: {bgImage.Name}, Key: {bgImage.Key}");
                    
                    var bgClass = $"{prefix}-img-{componentId.ToString().Replace("-", "").Substring(0, 8)}";
                    _logger.LogDebug($"Generated CSS class: {bgClass}");
                    
                    var minHeight = settings.HasValue("minHeight") ? settings.Value<int>("minHeight") : 400;
                    var bgSize = "cover";
                    var bgPosition = "center";
                    var bgRepeat = "no-repeat";
                    
                    if (settings.HasProperty("bgSize") && settings.HasValue("bgSize"))
                    {
                        var bgSizeValue = settings.Value<string>("bgSize");
                        if (!string.IsNullOrWhiteSpace(bgSizeValue))
                        {
                            bgSize = ConvertBgSizeToCss(bgSizeValue);
                            _logger.LogDebug($"Background size: {bgSizeValue} -> {bgSize}");
                        }
                    }
                    
                    bgPosition = settings.HasValue("backgroundPosition") 
                        ? settings.Value<string>("backgroundPosition") ?? "center"
                        : "center";
                    
                    _logger.LogDebug($"Background position: {bgPosition}, Min height: {minHeight}");
                    
                    var imageUrl = GetOptimizedImageUrl(bgImage, 1920, 80, "");
                    
                    _logger.LogInformation($"Image URL: {imageUrl}");
                    
                    // Простой CSS с data-атрибутами
                    var css = $@"
.{bgClass} {{
    position: relative;
    min-height: {minHeight}px;
    background-color: #f5f5f5;
}}";
                    
                    AddToCssStyles(css);
                    _logger.LogDebug("CSS styles added");
                    
                    // HTML с data-атрибутами для lazy loading
                    // JavaScript будет автоматически обработан внешним скриптом lazy-backgrounds.js
                    var html = $@"
<div class='{bgClass} lazy-background' 
     data-bg-url='{imageUrl}'
     data-bg-size='{bgSize}'
     data-bg-position='{bgPosition}'
     data-bg-repeat='{bgRepeat}'>
</div>";
                    
                    result.CssClass = bgClass;
                    result.HasBackground = true;
                    result.HtmlContent = html;
                    result.IsLazyLoaded = true;
                    
                    _logger.LogInformation($"Image background processed with lazy loading. CssClass: {bgClass}");
                }
                else
                {
                    _logger.LogWarning("Background image property exists but value is null");
                }
            }
            else
            {
                _logger.LogWarning("No backgroundImage property or value found");
            }
            
            return result;
        }

        private BackgroundResult ProcessColorBackground(IPublishedElement settings, Guid componentId, string prefix)
        {
            _logger.LogInformation($"Processing color background for component {componentId}");
            var result = new BackgroundResult { Type = BackgroundType.Color };
            
            if (settings.HasProperty("color") && settings.HasValue("color"))
            {
                var color = settings.Value<string>("color");
                if (!string.IsNullOrWhiteSpace(color))
                {
                    var bgClass = $"{prefix}-color-{componentId.ToString().Replace("-", "").Substring(0, 8)}";
                    var minHeight = settings.HasValue("minHeight") ? settings.Value<int>("minHeight") : 400;
                    
                    _logger.LogDebug($"Color: {color}, Min height: {minHeight}");
                    
                    var css = $@"
.{bgClass} {{
    background-color: {color};
    min-height: {minHeight}px;
    position: relative;
}}";
                    
                    result.CssClass = bgClass;
                    result.HasBackground = true;
                    AddToCssStyles(css);
                    _logger.LogInformation($"Color background processed. CssClass: {bgClass}");
                }
                else
                {
                    _logger.LogWarning("Color property exists but value is empty");
                }
            }
            else
            {
                _logger.LogWarning("No color property or value found");
            }
            
            return result;
        }

        private BackgroundResult ProcessGradientBackground(IPublishedElement settings, Guid componentId, string prefix)
        {
            _logger.LogInformation($"Processing gradient background for component {componentId}");
            var result = new BackgroundResult { Type = BackgroundType.Gradient };
            
            if (settings.HasProperty("colorStart") && settings.HasValue("colorStart") &&
                settings.HasProperty("colorEnd") && settings.HasValue("colorEnd"))
            {
                var colorStart = settings.Value<string>("colorStart");
                var colorEnd = settings.Value<string>("colorEnd");
                
                if (!string.IsNullOrWhiteSpace(colorStart) && !string.IsNullOrWhiteSpace(colorEnd))
                {
                    var bgClass = $"{prefix}-gradient-{componentId.ToString().Replace("-", "").Substring(0, 8)}";
                    
                    var direction = "to bottom";
                    if (settings.HasProperty("direction") && settings.HasValue("direction"))
                    {
                        var directionValue = settings.Value<string>("direction");
                        direction = ConvertDirectionToCss(directionValue);
                        _logger.LogDebug($"Gradient direction: {directionValue} -> {direction}");
                    }
                    
                    var minHeight = settings.HasValue("minHeight") ? settings.Value<int>("minHeight") : 400;
                    
                    _logger.LogDebug($"Gradient: {colorStart} to {colorEnd}, Direction: {direction}");
                    
                    var css = $@"
.{bgClass} {{
    background: linear-gradient({direction}, {colorStart}, {colorEnd});
    min-height: {minHeight}px;
    position: relative;
}}";
                    
                    result.CssClass = bgClass;
                    result.HasBackground = true;
                    AddToCssStyles(css);
                    _logger.LogInformation($"Gradient background processed. CssClass: {bgClass}");
                }
                else
                {
                    _logger.LogWarning("Gradient colors are empty");
                }
            }
            else
            {
                _logger.LogWarning("No gradient color properties found");
            }
            
            return result;
        }

        private BackgroundResult ProcessOptimizedVideoBackground(IPublishedElement settings, Guid componentId, string prefix)
        {
            _logger.LogInformation($"Processing video background for component {componentId}");
            var result = new BackgroundResult { Type = BackgroundType.Video };
            
            if (settings.HasProperty("video") && settings.HasValue("video"))
            {
                var videoUrl = settings.Value<string>("video");
                if (!string.IsNullOrWhiteSpace(videoUrl))
                {
                    var videoId = ExtractVimeoVideoId(videoUrl);
                    if (!string.IsNullOrEmpty(videoId))
                    {
                        _logger.LogInformation($"Vimeo video ID extracted: {videoId}");
                        
                        var bgClass = $"{prefix}-video-{componentId.ToString().Replace("-", "").Substring(0, 8)}";
                        var minHeight = settings.HasValue("minHeight") ? settings.Value<int>("minHeight") : 400;
                        
                        IPublishedContent? videoPlaceholder = null;
                        if (settings.HasProperty("videoPlaceholder") && settings.HasValue("videoPlaceholder"))
                        {
                            videoPlaceholder = settings.Value<IPublishedContent>("videoPlaceholder");
                            _logger.LogDebug($"Video placeholder found: {videoPlaceholder?.Name}");
                        }
                        
                        var isMobile = IsMobileDevice();
                        var usePlaceholder = isMobile && videoPlaceholder != null;
                        
                        _logger.LogInformation($"Is mobile: {isMobile}, Use placeholder: {usePlaceholder}");
                        
                        var css = GenerateOptimizedVideoCss(bgClass, minHeight, usePlaceholder);
                        var html = GenerateOptimizedVideoHtml(videoId, bgClass, videoPlaceholder, usePlaceholder);
                        
                        result.CssClass = bgClass;
                        result.HasBackground = true;
                        result.HtmlContent = html;
                        result.IsMobileOptimized = usePlaceholder;
                        result.IsLazyLoaded = true;
                        AddToCssStyles(css);
                        
                        _logger.LogInformation($"Video background processed. CssClass: {bgClass}");
                    }
                    else
                    {
                        _logger.LogWarning($"Could not extract Vimeo video ID from URL: {videoUrl}");
                    }
                }
                else
                {
                    _logger.LogWarning("Video URL is empty");
                }
            }
            else
            {
                _logger.LogWarning("No video property or value found");
            }
            
            return result;
        }

        private string GenerateOptimizedVideoHtml(string videoId, string bgClass, IPublishedContent? videoPlaceholder, bool usePlaceholder)
        {
            _logger.LogDebug($"Generating video HTML. VideoID: {videoId}, UsePlaceholder: {usePlaceholder}");
            
            if (usePlaceholder && videoPlaceholder != null)
            {
                var placeholderUrl = GetOptimizedImageUrl(videoPlaceholder, 768, 80, "");
                
                _logger.LogInformation($"Using placeholder image: {placeholderUrl}");
                
                return $@"
<div class='video-background-container' data-video-id='{videoId}' data-use-placeholder='true'>
    <img src='{placeholderUrl}' 
         alt='Video placeholder'
         class='video-placeholder'
         loading='lazy'
         style='width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;z-index:0;'>
</div>";
            }
            else
            {
                var vimeoThumbnail = $"https://i.vimeocdn.com/video/{videoId}_1280.jpg";
                _logger.LogInformation($"Using Vimeo thumbnail: {vimeoThumbnail}");
                
                return $@"
<div class='video-background-container' data-video-id='{videoId}' data-use-placeholder='false'>
    <img src='{vimeoThumbnail}' 
         alt='Video thumbnail'
         class='video-placeholder'
         loading='lazy'
         style='width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;z-index:0;'>
</div>
<script>
(function() {{
    function initVideoLazyLoad() {{
        var videoContainer = document.querySelector('.{bgClass} .video-background-container');
        if (!videoContainer) return;
        
        if (videoContainer.getAttribute('data-use-placeholder') === 'true') {{
            return;
        }}
        
        var observer = new IntersectionObserver(function(entries, observer) {{
            entries.forEach(function(entry) {{
                if (entry.isIntersecting) {{
                    var container = entry.target;
                    var videoId = container.getAttribute('data-video-id');
                    
                    var iframe = document.createElement('iframe');
                    iframe.className = 'video-background-iframe';
                    iframe.src = 'https://player.vimeo.com/video/' + videoId + '?background=1&muted=1&loop=1&autopause=0&controls=0&title=0&byline=0&portrait=0';
                    iframe.setAttribute('allow', 'autoplay; fullscreen');
                    iframe.setAttribute('allowfullscreen', '');
                    iframe.setAttribute('frameborder', '0');
                    iframe.setAttribute('scrolling', 'no');
                    iframe.style.cssText = 'position:absolute; top:50%; left:50%; width:177.77777778vh; min-width:100%; min-height:100%; height:56.25vw; transform:translate(-50%, -50%); border:none; z-index:0;';
                    
                    var placeholder = container.querySelector('.video-placeholder');
                    if (placeholder) {{
                        placeholder.style.transition = 'opacity 0.5s ease';
                        placeholder.style.opacity = '0';
                        setTimeout(function() {{
                            if (placeholder.parentNode) {{
                                placeholder.parentNode.removeChild(placeholder);
                            }}
                        }}, 500);
                    }}
                    
                    container.appendChild(iframe);
                    observer.unobserve(container);
                }}
            }});
        }}, {{ 
            rootMargin: '300px 0px',
            threshold: 0.1
        }});
        
        observer.observe(videoContainer);
    }}
    
    if (document.readyState === 'loading') {{
        document.addEventListener('DOMContentLoaded', initVideoLazyLoad);
    }} else {{
        initVideoLazyLoad();
    }}
}})();
</script>";
            }
        }

        private string GenerateOptimizedVideoCss(string bgClass, int minHeight, bool usePlaceholder)
        {
            _logger.LogDebug($"Generating video CSS. Class: {bgClass}, MinHeight: {minHeight}");
            
            var css = $@"
.{bgClass} {{
    position: relative;
    min-height: {minHeight}px;
    overflow: hidden;
}}
.{bgClass} .video-background-container {{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
}}";
            
            if (!usePlaceholder)
            {
                css += $@"
.{bgClass} .video-background-iframe {{
    position: absolute;
    top: 50%;
    left: 50%;
    width: 177.77777778vh;
    min-width: 100%;
    min-height: 100%;
    height: 56.25vw;
    transform: translate(-50%, -50%);
    border: 0;
    z-index: 0;
}}";
            }
            
            return css;
        }

        private string GetOptimizedImageUrl(IPublishedContent media, int width, int quality, string version)
        {
            var url = media.Url();
            _logger.LogInformation($"Media URL: {url}");
            return url;
        }

        private string GetMediaFileVersion(IPublishedContent media)
        {
            try
            {
                _logger.LogDebug($"Getting file version for media: {media.Name}, Key: {media.Key}");
                
                var mediaPath = GetMediaPhysicalPath(media);
                _logger.LogDebug($"Media physical path: {mediaPath}");
                
                if (!string.IsNullOrEmpty(mediaPath) && File.Exists(mediaPath))
                {
                    var lastModified = File.GetLastWriteTimeUtc(mediaPath);
                    var version = lastModified.Ticks.ToString();
                    _logger.LogDebug($"File exists. Last modified: {lastModified}, Version: {version}");
                    return version;
                }
                else
                {
                    _logger.LogWarning($"Media file not found at path: {mediaPath}");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error getting media version for {media.Name}");
            }
            
            var updateDate = media.UpdateDate != default ? media.UpdateDate : media.CreateDate;
            var fallbackVersion = updateDate.Ticks.ToString();
            _logger.LogDebug($"Using fallback version from update date: {updateDate}, Version: {fallbackVersion}");
            
            return fallbackVersion;
        }

        private string? GetMediaPhysicalPath(IPublishedContent media)
        {
            try
            {
                var umbracoFile = media.Value<string>("umbracoFile");
                _logger.LogDebug($"umbracoFile value: {umbracoFile}");
                
                if (!string.IsNullOrEmpty(umbracoFile))
                {
                    if (umbracoFile.StartsWith("/"))
                    {
                        var webRoot = _env.WebRootPath;
                        var fullPath = Path.Combine(webRoot, umbracoFile.TrimStart('/'));
                        _logger.LogDebug($"Relative path converted to: {fullPath}");
                        return fullPath;
                    }
                    
                    _logger.LogDebug($"Using absolute path: {umbracoFile}");
                    return umbracoFile;
                }
                else
                {
                    _logger.LogWarning("umbracoFile property is empty");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting media physical path");
            }
            
            return null;
        }

        private bool IsMobileDevice()
        {
            var httpContext = _httpContextAccessor.HttpContext;
            if (httpContext == null) 
            {
                _logger.LogWarning("HttpContext is null in IsMobileDevice");
                return false;
            }
            
            var userAgent = httpContext.Request.Headers["User-Agent"].ToString();
            if (string.IsNullOrEmpty(userAgent)) 
            {
                _logger.LogWarning("User-Agent header is empty");
                return false;
            }
            
            var mobileKeywords = new[] 
            { 
                "Mobile", "Android", "iPhone", "iPad", "iPod", 
                "BlackBerry", "Windows Phone", "webOS", "Opera Mini", "IEMobile"
            };
            
            var isMobile = mobileKeywords.Any(keyword => 
                userAgent.Contains(keyword, StringComparison.OrdinalIgnoreCase));
            
            return isMobile;
        }

        private string GenerateOverlayCss(IPublishedElement settings, string overlayType, string mainClass, BackgroundType bgType)
        {
            _logger.LogDebug($"Generating overlay CSS. Type: {overlayType}, MainClass: {mainClass}");
            
            var cssBuilder = new StringBuilder();
            
            cssBuilder.Append($@"
.{mainClass}.with-overlay::after {{
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}}");
            
            cssBuilder.Append($@"
.{mainClass} .container {{
    position: relative;
    z-index: 2;
}}");
            
            switch (overlayType)
            {
                case "Цвет":
                    if (settings.HasProperty("colorOverlay") && settings.HasValue("colorOverlay"))
                    {
                        var color = settings.Value<string>("colorOverlay");
                        if (!string.IsNullOrWhiteSpace(color))
                        {
                            cssBuilder.Append($@"
.{mainClass}.with-overlay::after {{
    background-color: {color};
}}");
                            _logger.LogDebug($"Color overlay: {color}");
                        }
                    }
                    break;
                    
                case "Изображение":
                    if (settings.HasProperty("imageOverlay") && settings.HasValue("imageOverlay"))
                    {
                        var image = settings.Value<IPublishedContent>("imageOverlay");
                        if (image != null)
                        {
                            var bgSize = "cover";
                            var bgPosition = "center";
                            var repeat = "no-repeat";
                            
                            if (settings.HasProperty("bgSizeOverlay") && settings.HasValue("bgSizeOverlay"))
                            {
                                var bgSizeValue = settings.Value<string>("bgSizeOverlay");
                                if (!string.IsNullOrWhiteSpace(bgSizeValue))
                                {
                                    bgSize = ConvertBgSizeToCss(bgSizeValue);
                                }
                            }
                            
                            if (settings.HasProperty("repeatOverlay") && settings.HasValue("repeatOverlay"))
                            {
                                var repeatValue = settings.Value<bool>("repeatOverlay");
                                repeat = repeatValue ? "repeat" : "no-repeat";
                            }
                            
                            var imageUrl = GetOptimizedImageUrl(image, 1920, 80, "");
                            
                            cssBuilder.Append($@"
.{mainClass}.with-overlay::after {{
    background-image: url('{imageUrl}');
    background-size: {bgSize};
    background-position: {bgPosition};
    background-repeat: {repeat};
}}");
                        }
                    }
                    break;
                    
                case "Градиент":
                    if (settings.HasProperty("colorStartOverlay") && settings.HasValue("colorStartOverlay") &&
                        settings.HasProperty("colorEndOverlay") && settings.HasValue("colorEndOverlay"))
                    {
                        var colorStart = settings.Value<string>("colorStartOverlay");
                        var colorEnd = settings.Value<string>("colorEndOverlay");
                        
                        var direction = "to bottom";
                        if (settings.HasProperty("directionOverlay") && settings.HasValue("directionOverlay"))
                        {
                            var directionValue = settings.Value<string>("directionOverlay");
                            direction = ConvertDirectionToCss(directionValue);
                        }
                        
                        cssBuilder.Append($@"
.{mainClass}.with-overlay::after {{
    background: linear-gradient({direction}, {colorStart}, {colorEnd});
}}");
                    }
                    break;
            }
            
            if (settings.HasProperty("opacityOverlay") && settings.HasValue("opacityOverlay"))
            {
                var opacityValue = settings.Value<int>("opacityOverlay");
                var opacity = opacityValue / 100.0;
                
                cssBuilder.Append($@"
.{mainClass}.with-overlay::after {{
    opacity: {opacity.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture)};
}}");
            }
            
            return cssBuilder.ToString();
        }

        private string? ExtractVimeoVideoId(string url)
        {
            if (string.IsNullOrWhiteSpace(url))
            {
                _logger.LogWarning("Video URL is empty");
                return null;
            }
            
            _logger.LogDebug($"Extracting Vimeo video ID from: {url}");
            url = url.Split('?')[0];
            
            var patterns = new[]
            {
                @"vimeo\.com/(?:.*/)?(\d+)",
                @"player\.vimeo\.com/video/(\d+)",
                @"vimeo\.com/channels/[^/]+/(\d+)",
                @"vimeo\.com/groups/[^/]+/videos/(\d+)"
            };
            
            foreach (var pattern in patterns)
            {
                try
                {
                    var regex = new Regex(pattern, RegexOptions.IgnoreCase);
                    var match = regex.Match(url);
                    
                    if (match.Success && match.Groups.Count > 1)
                    {
                        var id = match.Groups[1].Value;
                        if (!string.IsNullOrWhiteSpace(id) && id.All(char.IsDigit))
                        {
                            _logger.LogInformation($"Vimeo video ID extracted: {id}");
                            return id;
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, $"Error extracting Vimeo ID with pattern: {pattern}");
                }
            }
            
            _logger.LogWarning($"Could not extract Vimeo video ID from URL: {url}");
            return null;
        }

        private string ConvertBgSizeToCss(string bgSizeValue)
        {
            if (string.IsNullOrWhiteSpace(bgSizeValue))
                return "cover";
            
            var trimmedValue = bgSizeValue.Trim();
            
            return trimmedValue switch
            {
                "Как есть" => "auto",
                "По ширине" => "100% auto",
                "По высоте" => "auto 100%",
                "Обложка" => "cover",
                "Вместить" => "contain",
                _ => "cover"
            };
        }

        private string ConvertDirectionToCss(string? directionValue)
        {
            if (string.IsNullOrWhiteSpace(directionValue))
                return "to bottom";
            
            var trimmedValue = directionValue.Trim();
            
            return trimmedValue switch
            {
                "Сверху вниз" => "to bottom",
                "Снизу вверх" => "to top",
                "Слева направо" => "to right",
                "Справа налево" => "to left",
                _ => "to bottom"
            };
        }

        private void AddToCssStyles(string css)
        {
            var httpContext = _httpContextAccessor.HttpContext;
            if (httpContext == null)
            {
                _logger.LogWarning("HttpContext is null, cannot add CSS styles");
                return;
            }

            var cssStyles = httpContext.Items["BackgroundCss"] as List<string>;
            if (cssStyles == null)
            {
                cssStyles = new List<string>();
                httpContext.Items["BackgroundCss"] = cssStyles;
                _logger.LogDebug("Created new CSS styles list in HttpContext");
            }
            
            cssStyles.Add(css);
            _logger.LogDebug($"Added CSS to styles list. Total styles: {cssStyles.Count}");
        }
    }
}

// Функция для инициализации lazy loading фоновых изображений
function initLazyBackgrounds() {
    console.log('Lazy backgrounds initialization started');
    
    // Собираем все элементы с data-bg-url
    const lazyElements = document.querySelectorAll('[data-bg-url]');
    
    console.log(`Found ${lazyElements.length} lazy background elements`);
    
    if (lazyElements.length === 0) return;
    
    // Функция для загрузки фона
    function loadBackground(element) {
        if (element.dataset.bgLoaded === 'true') {
            console.log('Background already loaded for element');
            return;
        }
        
        const bgUrl = element.dataset.bgUrl;
        const bgSize = element.dataset.bgSize || 'cover';
        const bgPosition = element.dataset.bgPosition || 'center';
        const bgRepeat = element.dataset.bgRepeat || 'no-repeat';
        
        if (!bgUrl) {
            console.warn('No bg-url found for element');
            return;
        }
        
        console.log(`Loading background: ${bgUrl}`);
        
        // Создаем изображение для предзагрузки
        const img = new Image();
        
        // Добавляем обработчики ДО установки src
        img.onload = function() {
            console.log(`Background loaded: ${bgUrl}`);
            // Устанавливаем фон
            element.style.backgroundImage = `url("${bgUrl}")`;
            element.style.backgroundSize = bgSize;
            element.style.backgroundPosition = bgPosition;
            element.style.backgroundRepeat = bgRepeat;
            element.dataset.bgLoaded = 'true';
            element.classList.add('bg-loaded');
            
            // Удаляем placeholder цвет
            if (element.style.backgroundColor === 'rgb(245, 245, 245)') {
                element.style.backgroundColor = '';
            }
        };
        
        img.onerror = function() {
            console.error('Failed to load background image:', bgUrl);
            element.classList.add('bg-error');
            element.dataset.bgLoaded = 'error';
            
            // Установим цвет ошибки
            element.style.backgroundColor = '#ffe6e6';
        };
        
        // Устанавливаем src ПОСЛЕ добавления обработчиков
        img.src = bgUrl;
        
        // Если изображение уже кэшировано, onload может не сработать
        if (img.complete) {
            console.log('Image already cached, triggering load manually');
            img.onload();
        }
    }
    
    //wwwroot/js/lazy-backgrounds.js
    // Функция для проверки видимости элемента (более надежная)
    function isElementInViewport(el) {
        const rect = el.getBoundingClientRect();
        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);
        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);
        
        return (
            rect.top <= windowHeight &&
            rect.bottom >= 0 &&
            rect.left <= windowWidth &&
            rect.right >= 0
        );
    }
    
    // Проверяем поддержку IntersectionObserver
    if ('IntersectionObserver' in window) {
        console.log('Using IntersectionObserver');
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    console.log('Element entered viewport');
                    loadBackground(entry.target);
                    observer.unobserve(entry.target);
                }
            });
        }, {
            rootMargin: '100px 0px', // Увеличиваем область предзагрузки
            threshold: 0.01
        });
        
        // Начинаем наблюдение за каждым элементом
        lazyElements.forEach(element => {
            // Проверяем, виден ли элемент сразу
            if (isElementInViewport(element)) {
                console.log('Element already in viewport, loading immediately');
                // Небольшая задержка для стабильности
                setTimeout(() => loadBackground(element), 50);
            } else {
                // Иначе начинаем наблюдение
                console.log('Starting to observe element');
                observer.observe(element);
            }
        });
        
        // Добавляем обработчик скролла на всякий случай
        let scrollTimeout;
        const handleScroll = function() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                lazyElements.forEach(element => {
                    if (element.dataset.bgLoaded !== 'true' && 
                        element.dataset.bgLoaded !== 'error' && 
                        isElementInViewport(element)) {
                        console.log('Element scrolled into view, loading');
                        loadBackground(element);
                    }
                });
            }, 150);
        };
        
        // Используем passive event listener для производительности
        window.addEventListener('scroll', handleScroll, { passive: true });
        window.addEventListener('resize', handleScroll, { passive: true });
        
    } else {
        // Fallback для старых браузеров
        console.log('IntersectionObserver not supported, using fallback');
        lazyElements.forEach(element => {
            setTimeout(() => loadBackground(element), 100);
        });
    }
}

// Ждем полной загрузки DOM
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded - initializing lazy backgrounds');
    // Даем время на рендеринг
    setTimeout(initLazyBackgrounds, 100);
});

// Также запускаем после полной загрузки страницы
window.addEventListener('load', function() {
    console.log('Window loaded - reinitializing lazy backgrounds');
    // Проверяем еще раз через секунду
    setTimeout(initLazyBackgrounds, 1000);
});

// Инициализируем при изменении DOM (для SPA)
if (typeof MutationObserver !== 'undefined') {
    const domObserver = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.addedNodes.length) {
                console.log('DOM changed, checking for new lazy backgrounds');
                setTimeout(initLazyBackgrounds, 300);
            }
        });
    });
    
    // Начинаем наблюдение после загрузки DOM
    document.addEventListener('DOMContentLoaded', function() {
        domObserver.observe(document.body, {
            childList: true,
            subtree: true
        });
    });
}

// Экспортируем функцию для ручной инициализации
window.initLazyBackgrounds = initLazyBackgrounds;

// Автоматическая инициализация, если страница уже загружена
if (document.readyState === 'interactive' || document.readyState === 'complete') {
    setTimeout(initLazyBackgrounds, 100);
}

